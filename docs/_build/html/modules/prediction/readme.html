<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>15. Prediction &mdash; dig-into-apollo  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="16. Routing" href="../routing/readme.html" />
    <link rel="prev" title="14. Planning" href="../planning/readme.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> dig-into-apollo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">快速开始:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../what_is_apollo/readme.html">1. 什么是Apollo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to_build/readme.html">2. 如何编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docker/readme.html">3. 启动容器</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../cyber/readme.html">1. Cyber</a></li>
<li class="toctree-l1"><a class="reference internal" href="../audio/readme.html">2. Audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bridge/readme.html">3. Bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="../canbus/readme.html">4. Canbus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../control/readme.html">5. Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/readme.html">6. Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dreamview/readme.html">7. Dreamview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/readme.html">8. Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guardian/readme.html">9. Guardian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../localization/readme.html">10. Localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../map/readme.html">11. Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../monitor/readme.html">12. Monitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../perception/readme.html">13. Perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="../planning/readme.html">14. Planning</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">15. Prediction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">15.1. 介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">15.2. 目录结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="#predictioncomponent">15.3. 预测模块(PredictionComponent类)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#init">15.3.1. 初始化(Init())</a></li>
<li class="toctree-l3"><a class="reference internal" href="#proc">15.3.2. 回调执行(Proc)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#containersubmoduleprocess">15.3.3. ContainerSubmoduleProcess</a></li>
<li class="toctree-l3"><a class="reference internal" href="#predictionendtoendproc">15.3.4. PredictionEndToEndProc</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#messageprocess">15.4. 消息处理(MessageProcess)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">15.4.1. 初始化(Init)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">15.4.2. 消息处理</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#container">15.5. 容器(container)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">15.5.1. 容器基类(Container)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#containermanager">15.5.2. 容器管理(ContainerManager)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#posecontainer">15.5.3. 姿态容器(PoseContainer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adctrajectorycontainer">15.5.4. 规划轨迹容器(ADCTrajectoryContainer)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#storytellingcontainer">故事容器(StoryTellingContainer)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#obstaclescontainer">15.5.5. 障碍物容器(ObstaclesContainer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#roadgraph">15.5.6. 道路图(RoadGraph)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#scenario">15.6. 场景(scenario)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scenariomanager">15.6.1. 场景管理器(ScenarioManager)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#evaluator">15.7. 评估者(evaluator)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">15.7.1. 评估者基类(Evaluator)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#evaluatormanager">15.7.2. 评估者管理器(EvaluatorManager)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cyclistkeeplaneevaluator">15.7.3. 自行车评估者(CyclistKeepLaneEvaluator)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pedestrianinteractionevaluator">15.7.4. 行人互动评估者(PedestrianInteractionEvaluator)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#costevaluator">15.7.5. CostEvaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cruisemlpevaluator">15.7.6. CruiseMLPEvaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#junctionmapevaluator">15.7.7. JunctionMapEvaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#junctionmlpevaluator">15.7.8. JunctionMLPEvaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#laneaggregatingevaluator">15.7.9. LaneAggregatingEvaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lanescanningevaluator">15.7.10. LaneScanningEvaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mlpevaluator">15.7.11. MLPEvaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semanticlstmevaluator">15.7.12. SemanticLSTMEvaluator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#predictor">15.8. 预测器(predictor)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">15.8.1. 预测器基类(Predictor)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#predictormanager">15.8.2. 预测管理器(PredictorManager)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#emptypredictor">15.8.3. EmptyPredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extrapolationpredictor">15.8.4. ExtrapolationPredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#freemovepredictor">15.8.5. FreeMovePredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interactionpredictor">15.8.6. InteractionPredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#junctionpredictor">15.8.7. JunctionPredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lanesequencepredictor">15.8.8. LaneSequencePredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#movesequencepredictor">15.8.9. MoveSequencePredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequencepredictor">15.8.10. SequencePredictor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#singlelanepredictor">15.8.11. SingleLanePredictor</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reference">15.9. Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../routing/readme.html">16. Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../routing/readme.html#id5">17. Routing模块分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/readme.html">18. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../transform/readme.html">19. Transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../v2x/readme.html">20. V2X</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance/readme.html">21. 性能分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../simulation/readme.html">22. 仿真</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../library/readme.html">1. 引用的库</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../papers/readme.html">2. 论文</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../questions/readme.html">3. 常见问题</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dig-into-apollo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">&lt;no title&gt;</a> &raquo;</li>
      <li><span class="section-number">15. </span>Prediction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modules/prediction/readme.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="prediction">
<h1><span class="section-number">15. </span>Prediction<a class="headerlink" href="#prediction" title="Permalink to this headline"></a></h1>
<blockquote>
<div><p>悟已往之不谏,知来者之可追</p>
</div></blockquote>
<div class="section" id="id1">
<h2><span class="section-number">15.1. </span>介绍<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2>
<p>首先建议先阅读官方文档(readme.md)，里面说明了数据流向，也就是说预测模块是直接接收的感知模块给出的障碍物信息，这和CV领域的传统预测任务有区别，CV领域的预测任务不需要先识别物体，只需要根据物体的特征，对比前后2帧，然后得出物体的位置，也就说甚至不需要物体识别，业界之所以不这么做的原因是因为检测物体太耗时了。
当然也有先检测物体再做跟踪的，也就是说目前apollo中的物体检测实际上是采用的第二种方法，这也可以理解，反正感知模块一定会工作，而且一定要检测物体，所以何不把这个信息直接拿过来用呢？这和人类似，逐帧跟踪指定特征的对象，就是物体的轨迹，然后再根据现有的轨迹预测物体讲来的轨迹。
预测的轨迹和障碍物信息发送给规划(planning)模块使用。</p>
</div>
<div class="section" id="id2">
<h2><span class="section-number">15.2. </span>目录结构<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2>
<p>预测模块的目录结构如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.
├── BUILD
├── common                    // common目录，公用类
├── conf                      // 启动配置
├── container                 // 1. 消息容器
├── dag                       // 启动文件dag
├── data                      // 模型文件路径
├── evaluator                 // 3. 评估者
├── images                    // 文档（图片）
├── launch                    // 启动，加载模块
├── network
├── pipeline                  // 工具
├── prediction_component.cc       // 预测模块主入口
├── prediction_component.h
├── prediction_component_test.cc
├── predictor                // 4. 预测器
├── proto                   // protobuf消息格式
├── README_cn.md            // 文档（中文介绍，建议直接看英文）
├── README.md              // 文档（英文介绍）
├── scenario               // 2. 场景
├── submodules             // 子模块???
├── testdata               // 测试数据
└── util                   // 工具类
</pre></div>
</div>
<p>可以看到预测模块主要是分为2大块功能，一是实时的预测执行过程，一是工具类(离线验证？)：</p>
<ul class="simple">
<li><p><strong>在线预测流程</strong> - container -&gt; scenario -&gt; evaluator -&gt; predictor</p></li>
<li><p><strong>离线流程</strong> - pipeline (util)提取bag包中的数据给离线测试用？</p></li>
</ul>
</div>
<div class="section" id="predictioncomponent">
<h2><span class="section-number">15.3. </span>预测模块(PredictionComponent类)<a class="headerlink" href="#predictioncomponent" title="Permalink to this headline"></a></h2>
<p>预测模块和其它模块一样，都是在cyber中注册，具体的实现在”prediction_component.h”和”prediction_component.cc”中，我们知道cyber模块有2种消息触发模式，一种是定时器触发，一种是消息触发，而预测为消息触发模式。
预测模块的<strong>输入消息</strong>为：</p>
<ol class="arabic simple">
<li><p><strong>perception::PerceptionObstacles</strong> - 感知模块输出的障碍物信息</p></li>
<li><p><strong>planning::ADCTrajectory</strong> - 规划模块输出的行驶路径</p></li>
<li><p><strong>localization::LocalizationEstimate</strong> - 车辆当前的位置</p></li>
</ol>
<p><strong>输出消息</strong>:</p>
<ol class="arabic simple">
<li><p><strong>prediction::PredictionObstacles</strong> - 预测模块输出的障碍物信息</p></li>
</ol>
<p>预测模块和所有其它模块一样，都实现了”cyber::Component”基类中的”Init()”和”Proc()”方法，分别进行初始化和消息触发调用，调用由框架自动执行，关于cyber如何调用和执行每个模块，可以参考cyber模块的介绍，下面我们主要介绍这2个方法。</p>
<div class="section" id="init">
<h3><span class="section-number">15.3.1. </span>初始化(Init())<a class="headerlink" href="#init" title="Permalink to this headline"></a></h3>
<p>预测模块的初始化在”PredictionComponent::Init()”中进行，主要是注册消息读取和发送控制器，用来读取和发送消息，<strong>需要注意的是初始化过程中也对”MessageProcess”类进行了初始化，而”MessageProcess”实现了预测模块的整个消息处理流程</strong>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool PredictionComponent::Init() {
  component_start_time_ = Clock::NowInSeconds();

  // 预测模块消息处理流程初始化
  if (!MessageProcess::Init()) {
    return false;
  }

  // 规划模块消息读取者
  planning_reader_ = node_-&gt;CreateReader&lt;ADCTrajectory&gt;(
      FLAGS_planning_trajectory_topic, nullptr);

  // 定位模块消息读取者
  localization_reader_ =
      node_-&gt;CreateReader&lt;localization::LocalizationEstimate&gt;(
          FLAGS_localization_topic, nullptr);
  // 故事读取???
  storytelling_reader_ = node_-&gt;CreateReader&lt;storytelling::Stories&gt;(
      FLAGS_storytelling_topic, nullptr);
  // 预测消息发送者
  prediction_writer_ =
      node_-&gt;CreateWriter&lt;PredictionObstacles&gt;(FLAGS_prediction_topic);
  // 中间消息的发送者，这一块的目的是什么？？？
  container_writer_ =
      node_-&gt;CreateWriter&lt;SubmoduleOutput&gt;(FLAGS_container_topic_name);

  adc_container_writer_ = node_-&gt;CreateWriter&lt;ADCTrajectoryContainer&gt;(
      FLAGS_adccontainer_topic_name);

  perception_obstacles_writer_ = node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(
      FLAGS_perception_obstacles_topic_name);

  return true;
}
</pre></div>
</div>
<p>下面我们接着看消息回调执行函数</p>
</div>
<div class="section" id="proc">
<h3><span class="section-number">15.3.2. </span>回调执行(Proc)<a class="headerlink" href="#proc" title="Permalink to this headline"></a></h3>
<p>回调执行函数会执行以下过程:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool PredictionComponent::Proc(
    const std::shared_ptr&lt;PerceptionObstacles&gt;&amp; perception_obstacles) {
  // 1. 如果使用lego，则执行子过程
  if (FLAGS_use_lego) {
    return ContainerSubmoduleProcess(perception_obstacles);
  }
  // 2. 否则就执行端到端的过程
  return PredictionEndToEndProc(perception_obstacles);
}
</pre></div>
</div>
<p>下面我们分别看下这2个过程有什么差异？我们先看</p>
</div>
<div class="section" id="containersubmoduleprocess">
<h3><span class="section-number">15.3.3. </span>ContainerSubmoduleProcess<a class="headerlink" href="#containersubmoduleprocess" title="Permalink to this headline"></a></h3>
<p>子过程的函数如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">PredictionComponent::ContainerSubmoduleProcess</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PerceptionObstacles</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">perception_obstacles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">kHistorySize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">frame_start_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">absl</span><span class="o">::</span><span class="n">Now</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Read localization info. and call OnLocalization to update</span>
<span class="w">  </span><span class="c1">// the PoseContainer.</span>
<span class="w">  </span><span class="c1">// 读取定位信息，并且更新位置容器</span>
<span class="w">  </span><span class="n">localization_reader_</span><span class="o">-&gt;</span><span class="n">Observe</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_localization_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">localization_reader_</span><span class="o">-&gt;</span><span class="n">GetLatestObserved</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_localization_msg</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Prediction: cannot receive any localization message.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">MessageProcess</span><span class="o">::</span><span class="n">OnLocalization</span><span class="p">(</span><span class="o">*</span><span class="n">ptr_localization_msg</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Read planning info. of last frame and call OnPlanning to update</span>
<span class="w">  </span><span class="c1">// the ADCTrajectoryContainer</span>
<span class="w">  </span><span class="c1">// 读取规划路径，并且更新路径容器</span>
<span class="w">  </span><span class="n">planning_reader_</span><span class="o">-&gt;</span><span class="n">Observe</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_trajectory_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">planning_reader_</span><span class="o">-&gt;</span><span class="n">GetLatestObserved</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_trajectory_msg</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MessageProcess</span><span class="o">::</span><span class="n">OnPlanning</span><span class="p">(</span><span class="o">*</span><span class="n">ptr_trajectory_msg</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Read storytelling message and call OnStorytelling to update the</span>
<span class="w">  </span><span class="c1">// StoryTellingContainer</span>
<span class="w">  </span><span class="c1">// 读取故事消息，并且更新故事容器？？？</span>
<span class="w">  </span><span class="n">storytelling_reader_</span><span class="o">-&gt;</span><span class="n">Observe</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_storytelling_msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">storytelling_reader_</span><span class="o">-&gt;</span><span class="n">GetLatestObserved</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_storytelling_msg</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MessageProcess</span><span class="o">::</span><span class="n">OnStoryTelling</span><span class="p">(</span><span class="o">*</span><span class="n">ptr_storytelling_msg</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">MessageProcess</span><span class="o">::</span><span class="n">ContainerProcess</span><span class="p">(</span><span class="o">*</span><span class="n">perception_obstacles</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 障碍物容器指针</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">obstacles_container_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">ContainerManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetContainer</span><span class="o">&lt;</span><span class="n">ObstaclesContainer</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">AdapterConfig</span><span class="o">::</span><span class="n">PERCEPTION_OBSTACLES</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">obstacles_container_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 路径规划容器指针</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">adc_trajectory_container_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">ContainerManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetContainer</span><span class="o">&lt;</span><span class="n">ADCTrajectoryContainer</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">AdapterConfig</span><span class="o">::</span><span class="n">PLANNING_TRAJECTORY</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">adc_trajectory_container_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 输出障碍物信息</span>
<span class="w">  </span><span class="n">SubmoduleOutput</span><span class="w"> </span><span class="n">submodule_output</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">obstacles_container_ptr</span><span class="o">-&gt;</span><span class="n">GetSubmoduleOutput</span><span class="p">(</span><span class="n">kHistorySize</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                  </span><span class="n">frame_start_time</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 发布消息</span>
<span class="w">  </span><span class="n">container_writer_</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="n">submodule_output</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">adc_container_writer_</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="o">*</span><span class="n">adc_trajectory_container_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">perception_obstacles_writer_</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="o">*</span><span class="n">perception_obstacles</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>看起来上述函数只是计算中间过程，并且发布消息到订阅节点。具体的用途需要结合业务来分析（具体的业务场景是什么？？？）。</p>
</div>
<div class="section" id="predictionendtoendproc">
<h3><span class="section-number">15.3.4. </span>PredictionEndToEndProc<a class="headerlink" href="#predictionendtoendproc" title="Permalink to this headline"></a></h3>
<p>端到端的过程函数如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool PredictionComponent::PredictionEndToEndProc(
    const std::shared_ptr&lt;PerceptionObstacles&gt;&amp; perception_obstacles) {

  // Update relative map if needed
  // 如果是导航模式，需要判断地图是否准备好
  if (FLAGS_use_navigation_mode &amp;&amp; !PredictionMap::Ready()) {
    AERROR &lt;&lt; &quot;Relative map is empty.&quot;;
    return false;
  }

  // Read localization info. and call OnLocalization to update
  // the PoseContainer.
  // 读取定位消息，并且处理消息
  localization_reader_-&gt;Observe();
  auto ptr_localization_msg = localization_reader_-&gt;GetLatestObserved();
  MessageProcess::OnLocalization(*ptr_localization_msg);

  // Read storytelling message and call OnStorytelling to update the
  // StoryTellingContainer
  // 读取并且处理故事消息？？？
  storytelling_reader_-&gt;Observe();
  auto ptr_storytelling_msg = storytelling_reader_-&gt;GetLatestObserved();
  if (ptr_storytelling_msg != nullptr) {
    MessageProcess::OnStoryTelling(*ptr_storytelling_msg);
  }

  // Read planning info. of last frame and call OnPlanning to update
  // the ADCTrajectoryContainer
  // 读取并且处理规划消息
  planning_reader_-&gt;Observe();
  auto ptr_trajectory_msg = planning_reader_-&gt;GetLatestObserved();
  if (ptr_trajectory_msg != nullptr) {
    MessageProcess::OnPlanning(*ptr_trajectory_msg);
  }


  // Get all perception_obstacles of this frame and call OnPerception to
  // process them all.
  // 处理障碍物消息
  auto perception_msg = *perception_obstacles;
  PredictionObstacles prediction_obstacles;
  MessageProcess::OnPerception(perception_msg, &amp;prediction_obstacles);


  // 填充发布预测的障碍物轨迹消息
  // Postprocess prediction obstacles message
  prediction_obstacles.set_start_timestamp(frame_start_time_);
  ...

  common::util::FillHeader(node_-&gt;Name(), &amp;prediction_obstacles);
  prediction_writer_-&gt;Write(prediction_obstacles);
  return true;
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="messageprocess">
<h2><span class="section-number">15.4. </span>消息处理(MessageProcess)<a class="headerlink" href="#messageprocess" title="Permalink to this headline"></a></h2>
<p>可以看到上述过程都是在MessageProcess中处理完成的，那么我们先看下MessageProcess的执行过程。</p>
<div class="section" id="id3">
<h3><span class="section-number">15.4.1. </span>初始化(Init)<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h3>
<p>消息处理的初始化首先在”PredictionComponent::Init()”中调用，下面我们看下实现了哪些功能：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">MessageProcess::Init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 初始化容器</span>
<span class="w">  </span><span class="n">InitContainers</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 2. 初始化评估器</span>
<span class="w">  </span><span class="n">InitEvaluators</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 3. 初始化预测器</span>
<span class="w">  </span><span class="n">InitPredictors</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 如果为导航模式，则判断地图是否加载</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">FLAGS_use_navigation_mode</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">PredictionMap</span><span class="o">::</span><span class="n">Ready</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Map cannot be loaded.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述子过程的初始化就是从配置文件读取配置，并且初始化对应的类，结构相对比较简单，这里就不一一介绍了。</p>
</div>
<div class="section" id="id4">
<h3><span class="section-number">15.4.2. </span>消息处理<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h3>
<p>定位，规划和故事的消息处理相对比较简单，主要是向对应的容器中插入数据（每个容器都实现了Insert()方法），下面着重介绍感知模块消息的处理过程，该过程也输出了最后的结果。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MessageProcess::OnPerception</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacles</span><span class="o">&amp;</span><span class="w"> </span><span class="n">perception_obstacles</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">PredictionObstacles</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">prediction_obstacles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 分析场景和处理容器中的数据</span>
<span class="w">  </span><span class="n">ContainerProcess</span><span class="p">(</span><span class="n">perception_obstacles</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取障碍物容器</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_obstacles_container</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">ContainerManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetContainer</span><span class="o">&lt;</span><span class="n">ObstaclesContainer</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">AdapterConfig</span><span class="o">::</span><span class="n">PERCEPTION_OBSTACLES</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 获取规划曲线容器</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr_ego_trajectory_container</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">ContainerManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetContainer</span><span class="o">&lt;</span><span class="n">ADCTrajectoryContainer</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">AdapterConfig</span><span class="o">::</span><span class="n">PLANNING_TRAJECTORY</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Insert features to FeatureOutput for offline_mode</span>
<span class="w">  </span><span class="c1">// 离线模式，保存障碍物曲线？？？</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FLAGS_prediction_offline_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PredictionConstants</span><span class="o">::</span><span class="n">kDumpFeatureProto</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="w">         </span><span class="n">ptr_obstacles_container</span><span class="o">-&gt;</span><span class="n">curr_frame_movable_obstacle_ids</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">Obstacle</span><span class="o">*</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr_obstacles_container</span><span class="o">-&gt;</span><span class="n">GetObstacle</span><span class="p">(</span><span class="n">id</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obstacle_ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Null obstacle found.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">latest_feature</span><span class="p">().</span><span class="n">IsInitialized</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Obstacle [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] has no latest feature.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// TODO(all): the adc trajectory should be part of features for learning</span>
<span class="w">      </span><span class="c1">//            algorithms rather than part of the feature.proto</span>
<span class="w">      </span><span class="cm">/*</span>
<span class="cm">      *obstacle_ptr-&gt;mutable_latest_feature()-&gt;mutable_adc_trajectory_point() =</span>
<span class="cm">          ptr_ego_trajectory_container-&gt;adc_trajectory().trajectory_point();</span>
<span class="cm">      */</span><span class="w"></span>
<span class="w">      </span><span class="n">FeatureOutput</span><span class="o">::</span><span class="n">InsertFeatureProto</span><span class="p">(</span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">latest_feature</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Insert feature into feature output&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Not doing evaluation on offline mode</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Make evaluations</span>
<span class="w">  </span><span class="c1">// 2. 进行评估</span>
<span class="w">  </span><span class="n">EvaluatorManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">(</span><span class="n">ptr_obstacles_container</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FLAGS_prediction_offline_mode</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">          </span><span class="n">PredictionConstants</span><span class="o">::</span><span class="n">kDumpDataForLearning</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="n">FLAGS_prediction_offline_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PredictionConstants</span><span class="o">::</span><span class="n">kDumpFrameEnv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Make predictions</span>
<span class="w">  </span><span class="c1">// 3. 进行预测</span>
<span class="w">  </span><span class="n">PredictorManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">(</span><span class="n">perception_obstacles</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">ptr_ego_trajectory_container</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">ptr_obstacles_container</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Get predicted obstacles</span>
<span class="w">  </span><span class="c1">// 4. 输出预测结果</span>
<span class="w">  </span><span class="o">*</span><span class="n">prediction_obstacles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PredictorManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">prediction_obstacles</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上面的消息处理过程实际上是整个预测的过程，分为以下几个步骤：
<img alt="process" src="../../_images/process1.jpg" /></p>
<p>下面主要分析各个模块的输入是什么，输出是什么？ 以及它们的作用？</p>
</div>
</div>
<div class="section" id="container">
<h2><span class="section-number">15.5. </span>容器(container)<a class="headerlink" href="#container" title="Permalink to this headline"></a></h2>
<p>容器的作用主要是存储对应类型的消息，用来给评估器(evaluator)使用。</p>
<div class="section" id="id5">
<h3><span class="section-number">15.5.1. </span>容器基类(Container)<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h3>
<p>首先介绍容器基类”Container”类，主要申明了”Insert”方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
  <span class="n">Container</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>

  <span class="n">virtual</span> <span class="o">~</span><span class="n">Container</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">子类重写Insert方法</span>
  <span class="n">virtual</span> <span class="n">void</span> <span class="n">Insert</span><span class="p">(</span><span class="n">const</span> <span class="p">::</span><span class="n">google</span><span class="p">::</span><span class="n">protobuf</span><span class="p">::</span><span class="n">Message</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="containermanager">
<h3><span class="section-number">15.5.2. </span>容器管理(ContainerManager)<a class="headerlink" href="#containermanager" title="Permalink to this headline"></a></h3>
<p>上述基类有4个扩展类：PoseContainer，ObstaclesContainer，ADCTrajectoryContainer和StoryTellingContainer，分别存储不同的消息类型，而这些容器的管理和注册在ContainerManager中，下面我们看下ContainerManager类的具体实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ContainerManager</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 初始化</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">adapter</span><span class="o">::</span><span class="n">AdapterManagerConfig</span><span class="w"> </span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取容器模板</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">GetContainer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">adapter</span><span class="o">::</span><span class="n">AdapterConfig</span><span class="o">::</span><span class="n">MessageType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">key_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">type</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">containers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">containers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">containers_</span><span class="p">[</span><span class="n">key_type</span><span class="p">].</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// gtest 可以访问被测试类的私有成员</span>
<span class="w">  </span><span class="n">FRIEND_TEST</span><span class="p">(</span><span class="n">FeatureExtractorTest</span><span class="p">,</span><span class="w"> </span><span class="n">junction</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">FRIEND_TEST</span><span class="p">(</span><span class="n">ScenarioManagerTest</span><span class="p">,</span><span class="w"> </span><span class="n">run</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 注册容器</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">RegisterContainer</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">adapter</span><span class="o">::</span><span class="n">AdapterConfig</span><span class="o">::</span><span class="n">MessageType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 创建容器</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CreateContainer</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">adapter</span><span class="o">::</span><span class="n">AdapterConfig</span><span class="o">::</span><span class="n">MessageType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 注册所有的容器</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">RegisterContainers</span><span class="p">();</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 容器map，保存所有已经创建的容器</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">containers_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 配置文件</span>
<span class="w">  </span><span class="n">common</span><span class="o">::</span><span class="n">adapter</span><span class="o">::</span><span class="n">AdapterManagerConfig</span><span class="w"> </span><span class="n">config_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 单例</span>
<span class="w">  </span><span class="n">DECLARE_SINGLETON</span><span class="p">(</span><span class="n">ContainerManager</span><span class="p">)</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>ContainerManager类的执行过程如下：
<img alt="container" src="../../_images/container.jpg" />
可以看到容器管理器在Init中根据配置文件创建并且注册对应类型的容器，并且放到”containers_”中，而”containers_”为map结构，其中key为容器的类型，而值为对应的容器。注册之后通过”GetContainer”获取对应类型的容器。
总结起来就是”ContainerManager”负责从配置文件注册并且管理对应的容器。</p>
</div>
<div class="section" id="posecontainer">
<h3><span class="section-number">15.5.3. </span>姿态容器(PoseContainer)<a class="headerlink" href="#posecontainer" title="Permalink to this headline"></a></h3>
<p>姿态容器主要是根据”localization::LocalizationEstimate”消息转换为障碍物(perception::PerceptionObstacle)信息，这其实是把本车转换为障碍物。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PoseContainer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Container</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">PoseContainer</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">PoseContainer</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 插入消息</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取障碍物信息(这里就是本车)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacle</span><span class="o">*</span><span class="w"> </span><span class="nf">ToPerceptionObstacle</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">GetTimestamp</span><span class="p">();</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 根据本车位置转换为障碍物信息</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Update</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">localization</span><span class="o">::</span><span class="n">LocalizationEstimate</span><span class="o">&amp;</span><span class="w"> </span><span class="n">localization</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类型赋值为车</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacle</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">type_</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacle</span><span class="o">::</span><span class="n">VEHICLE</span><span class="p">;</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 障碍物指针</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacle</span><span class="o">&gt;</span><span class="w"> </span><span class="n">obstacle_ptr_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>姿态容器(PoseContainer)中主要注意”PoseContainer::Update”方法的实现，即把当前车辆转换为障碍物信息，由于该函数实现比较简单，这里就不展开了。</p>
</div>
<div class="section" id="adctrajectorycontainer">
<h3><span class="section-number">15.5.4. </span>规划轨迹容器(ADCTrajectoryContainer)<a class="headerlink" href="#adctrajectorycontainer" title="Permalink to this headline"></a></h3>
<p>ADCTrajectoryContainer类的具体实现如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ADCTrajectoryContainer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Container</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>

<span class="w">  </span><span class="n">ADCTrajectoryContainer</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">ADCTrajectoryContainer</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 插入消息</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 是否受到保护???</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsProtected</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 确认点是否在路口之中</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsPointInJunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">PathPoint</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 当前的道路序列是否和规划的轨迹有重叠???</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">HasOverlap</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LaneSequence</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane_sequence</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 设置位置</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetPosition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">math</span><span class="o">::</span><span class="n">Vec2d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">position</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取规划轨迹中的路口</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">hdmap</span><span class="o">::</span><span class="n">JunctionInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ADCJunction</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取到路口的距离</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">ADCDistanceToJunction</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取规划轨迹</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">planning</span><span class="o">::</span><span class="n">ADCTrajectory</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">adc_trajectory</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 道路是否在参考线中</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsLaneIdInReferenceLine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane_id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsLaneIdInTargetReferenceLine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane_id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 获取道路序列</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">GetADCLaneIDSequence</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">GetADCTargetLaneIDSequence</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 设置路口???</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetJunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">junction_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 设置路口的形状</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SetJunctionPolygon</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 设置道路序列</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetLaneSequence</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetTargetLaneSequence</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 道路id转换为字符串</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">ToString</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lane_ids</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">ToString</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lane_ids</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">planning</span><span class="o">::</span><span class="n">ADCTrajectory</span><span class="w"> </span><span class="n">adc_trajectory_</span><span class="p">;</span><span class="w">          </span><span class="c1">// 规划轨迹</span>
<span class="w">  </span><span class="n">common</span><span class="o">::</span><span class="n">math</span><span class="o">::</span><span class="n">Polygon2d</span><span class="w"> </span><span class="n">adc_junction_polygon_</span><span class="p">;</span><span class="w">    </span><span class="c1">// 轨迹的路口形状</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">hdmap</span><span class="o">::</span><span class="n">JunctionInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adc_junction_info_ptr_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">s_dist_to_junction_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adc_lane_ids_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adc_lane_seq_</span><span class="p">;</span><span class="w">           </span><span class="c1">// 轨迹道路序列</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adc_target_lane_ids_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adc_target_lane_seq_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>还是一样查看对应的”Insert”函数中实现了哪些功能？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ADCTrajectoryContainer::Insert</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">adc_lane_ids_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">adc_lane_seq_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">adc_target_lane_ids_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">adc_target_lane_seq_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">adc_junction_polygon_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Polygon2d</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 获取规划轨迹</span>
<span class="w">  </span><span class="n">adc_trajectory_</span><span class="p">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">ADCTrajectory</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">message</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 设置道路序列</span>
<span class="w">  </span><span class="n">SetLaneSequence</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 设置目标道路序列</span>
<span class="w">  </span><span class="n">SetTargetLaneSequence</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>可以看到”Insert”函数主要实现了规划轨迹的赋值操作，也就是保存规划轨迹的信息，<strong>而其它函数的功能，主要用来场景(scenario)识别中</strong>，我们在看到具体的场景识别的时候再展开分析。</p>
<div class="section" id="storytellingcontainer">
<h4>故事容器(StoryTellingContainer)<a class="headerlink" href="#storytellingcontainer" title="Permalink to this headline"></a></h4>
<p>StoryTellingContainer类和其它上述容器的实现类似:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">StoryTellingContainer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Container</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">StoryTellingContainer</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">StoryTellingContainer</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 插入storytelling::Stories信息</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取路口信息</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">hdmap</span><span class="o">::</span><span class="n">JunctionInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ADCJunction</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取路口Id</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">ADCJunctionId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 计算到路口的距离</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">ADCDistanceToJunction</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">storytelling</span><span class="o">::</span><span class="n">CloseToJunction</span><span class="w"> </span><span class="n">close_to_junction_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>StoryTellingContainer类实际上是接收”storytelling”模块的消息，来获取当前车和路口的距离。</p>
</div>
</div>
<div class="section" id="obstaclescontainer">
<h3><span class="section-number">15.5.5. </span>障碍物容器(ObstaclesContainer)<a class="headerlink" href="#obstaclescontainer" title="Permalink to this headline"></a></h3>
<p>我们最后介绍障碍物容器，实际上障碍物分为2块，一种是障碍物(Obstacle)，一种是障碍物簇(ObstacleClusters)，下面我们分别开始介绍：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ObstaclesContainer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Container</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">ObstaclesContainer</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">ObstaclesContainer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SubmoduleOutput</span><span class="o">&amp;</span><span class="w"> </span><span class="n">submodule_output</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">ObstaclesContainer</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 插入障碍物(PerceptionObstacles)信息</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 插入障碍物信息和时间戳</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">InsertPerceptionObstacle</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacle</span><span class="o">&amp;</span><span class="w"> </span><span class="n">perception_obstacle</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">timestamp</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 根据特征创建并且插入对应的障碍物</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">InsertFeatureProto</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Feature</span><span class="o">&amp;</span><span class="w"> </span><span class="n">feature</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 创建道路图结构</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">BuildLaneGraph</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 创建路口的特征</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">BuildJunctionFeature</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 根据id获取障碍物</span>
<span class="w">  </span><span class="n">Obstacle</span><span class="o">*</span><span class="w"> </span><span class="nf">GetObstacle</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 清空障碍物容器???</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Clear</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">CleanUp</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">NumOfObstacles</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">ptr_obstacles_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 根据id获取障碍物</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">apollo</span><span class="o">::</span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacle</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">GetPerceptionObstacle</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 当前帧的移动障碍物id</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">curr_frame_movable_obstacle_ids</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 当前帧不能移动的障碍物id</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">curr_frame_unmovable_obstacle_ids</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 当前帧中不能忽略的障碍物信息</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">curr_frame_considered_obstacle_ids</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 设置不能忽略的障碍物id</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetConsideredObstacleIds</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 当前帧中的障碍物id</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">curr_frame_obstacle_ids</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">timestamp</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取子模块输出</span>
<span class="w">  </span><span class="n">SubmoduleOutput</span><span class="w"> </span><span class="nf">GetSubmoduleOutput</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">history_size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">absl</span><span class="o">::</span><span class="n">Time</span><span class="o">&amp;</span><span class="w"> </span><span class="n">frame_start_time</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 根据最近最少使用的原则获取障碍物</span>
<span class="w">  </span><span class="n">Obstacle</span><span class="o">*</span><span class="w"> </span><span class="n">GetObstacleWithLRUUpdate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">obstacle_id</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 是否移动</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsMovable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">perception</span><span class="o">::</span><span class="n">PerceptionObstacle</span><span class="o">&amp;</span><span class="w"> </span><span class="n">perception_obstacle</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">timestamp_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">common</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">LRUCache</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Obstacle</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ptr_obstacles_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">curr_frame_movable_obstacle_ids_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">curr_frame_unmovable_obstacle_ids_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">curr_frame_considered_obstacle_ids_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>可以看到障碍物容器主要是根据不同的障碍物测量保存障碍物信息，下面我们看下相应的流程图：
<img alt="obs_process" src="../../_images/obs_process.jpg" />
可以看到上述过程中的主要功能实现都在”Obstacle”类中，下面我们主要分析下”Obstacle”类中的几个函数。</p>
<p>我们接着看”Obstacle”类的消息插入函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">Obstacle::Insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PerceptionObstacle</span><span class="o">&amp;</span><span class="w"> </span><span class="n">perception_obstacle</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">timestamp</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">prediction_obstacle_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 是否是过时的消息</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ReceivedOlderMessage</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 把障碍物的信息赋值给feature，包括Id,Type,Status</span>
<span class="w">  </span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">SetId</span><span class="p">(</span><span class="n">perception_obstacle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">feature</span><span class="p">,</span><span class="w"> </span><span class="n">prediction_obstacle_id</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">SetType</span><span class="p">(</span><span class="n">perception_obstacle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">feature</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">SetStatus</span><span class="p">(</span><span class="n">perception_obstacle</span><span class="p">,</span><span class="w"> </span><span class="n">timestamp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">feature</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Set obstacle lane features</span>
<span class="w">  </span><span class="c1">// 设置障碍物lane特征</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">type_</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">PerceptionObstacle</span><span class="o">::</span><span class="n">PEDESTRIAN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">SetCurrentLanes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">feature</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">SetNearbyLanes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">feature</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 根据lane调整车辆的方向</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FLAGS_adjust_vehicle_heading_by_lane</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">type_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PerceptionObstacle</span><span class="o">::</span><span class="n">VEHICLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AdjustHeadingByLane</span><span class="p">(</span><span class="o">&amp;</span><span class="n">feature</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 将障碍物特征保存到历史(feature_history_)</span>
<span class="w">  </span><span class="n">InsertFeatureToHistory</span><span class="p">(</span><span class="n">feature</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 设置障碍物运动状态(set_is_still)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FLAGS_use_navigation_mode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">SetMotionStatusBySpeed</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">SetMotionStatus</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 删除过去的历史特征(feature_history_)</span>
<span class="w">  </span><span class="n">DiscardOutdatedHistory</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>其中还用到了卡尔曼(KalmanFilter)滤波？？？</p>
<p>我们接着看BuildLaneGraph函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Obstacle::BuildLaneGraph</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">Feature</span><span class="o">*</span><span class="w"> </span><span class="n">feature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mutable_latest_feature</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// No need to BuildLaneGraph for those non-moving obstacles.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">is_still</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">id_</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">FLAGS_ego_vehicle_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Not build lane graph for still obstacle&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">lane_graph</span><span class="p">().</span><span class="n">lane_sequence_size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Not build lane graph for an old obstacle&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">t_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FLAGS_prediction_trajectory_time_length</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">estimated_move_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t_max</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">road_graph_search_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">estimated_move_distance</span><span class="p">,</span><span class="w"> </span><span class="n">FLAGS_min_prediction_trajectory_spatial_length</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_in_junction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HasJunctionFeatureWithExits</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exit_lane_id_set</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_in_junction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">exit</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">junction_feature</span><span class="p">().</span><span class="n">junction_exit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">exit_lane_id_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">exit</span><span class="p">.</span><span class="n">exit_lane_id</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// BuildLaneGraph for current lanes:</span>
<span class="w">  </span><span class="c1">// Go through all the LaneSegments in current_lane,</span>
<span class="w">  </span><span class="c1">// construct up to max_num_current_lane of them.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">seq_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">curr_lane_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">current_lane_feature</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">LaneInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lane_info</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">PredictionMap</span><span class="o">::</span><span class="n">LaneById</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_id</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">LaneGraph</span><span class="w"> </span><span class="n">lane_graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ObstacleClusters</span><span class="o">::</span><span class="n">GetLaneGraph</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">lane</span><span class="p">.</span><span class="n">lane_s</span><span class="p">(),</span><span class="w"> </span><span class="n">road_graph_search_distance</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">lane_info</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_graph</span><span class="p">.</span><span class="n">lane_sequence_size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">curr_lane_count</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane_seq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lane_graph</span><span class="p">.</span><span class="n">lane_sequence</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_in_junction</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">HasJunctionExitLane</span><span class="p">(</span><span class="n">lane_seq</span><span class="p">,</span><span class="w"> </span><span class="n">exit_lane_id_set</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">LaneSequence</span><span class="o">*</span><span class="w"> </span><span class="n">lane_seq_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">mutable_lane</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mutable_lane_graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">add_lane_sequence</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">lane_seq</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_sequence_id</span><span class="p">(</span><span class="n">seq_id</span><span class="o">++</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_s</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_s</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_l</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_l</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_vehicle_on_lane</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_type</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_type</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">SetLaneSequenceStopSign</span><span class="p">(</span><span class="n">lane_seq_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Obstacle [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">id_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] set a lane sequence [&quot;</span><span class="w"></span>
<span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lane_seq</span><span class="p">.</span><span class="n">ShortDebugString</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;].&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_lane_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">FLAGS_max_num_current_lane</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// BuildLaneGraph for neighbor lanes.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nearby_lane_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">nearby_lane_feature</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">LaneInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lane_info</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">PredictionMap</span><span class="o">::</span><span class="n">LaneById</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_id</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">LaneGraph</span><span class="w"> </span><span class="n">lane_graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ObstacleClusters</span><span class="o">::</span><span class="n">GetLaneGraph</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">lane</span><span class="p">.</span><span class="n">lane_s</span><span class="p">(),</span><span class="w"> </span><span class="n">road_graph_search_distance</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">lane_info</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_graph</span><span class="p">.</span><span class="n">lane_sequence_size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">nearby_lane_count</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane_seq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lane_graph</span><span class="p">.</span><span class="n">lane_sequence</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_in_junction</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">HasJunctionExitLane</span><span class="p">(</span><span class="n">lane_seq</span><span class="p">,</span><span class="w"> </span><span class="n">exit_lane_id_set</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">LaneSequence</span><span class="o">*</span><span class="w"> </span><span class="n">lane_seq_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">mutable_lane</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mutable_lane_graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">add_lane_sequence</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">lane_seq</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_sequence_id</span><span class="p">(</span><span class="n">seq_id</span><span class="o">++</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_s</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_s</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_l</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_l</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_vehicle_on_lane</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_seq_ptr</span><span class="o">-&gt;</span><span class="n">set_lane_type</span><span class="p">(</span><span class="n">lane</span><span class="p">.</span><span class="n">lane_type</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">SetLaneSequenceStopSign</span><span class="p">(</span><span class="n">lane_seq_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Obstacle [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">id_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] set a lane sequence [&quot;</span><span class="w"></span>
<span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lane_seq</span><span class="p">.</span><span class="n">ShortDebugString</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;].&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nearby_lane_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">FLAGS_max_num_nearby_lane</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">has_lane</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">has_lane_graph</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">SetLanePoints</span><span class="p">(</span><span class="n">feature</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">SetLaneSequencePath</span><span class="p">(</span><span class="n">feature</span><span class="o">-&gt;</span><span class="n">mutable_lane</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mutable_lane_graph</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Obstacle [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">id_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] set lane graph features.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="roadgraph">
<h3><span class="section-number">15.5.6. </span>道路图(RoadGraph)<a class="headerlink" href="#roadgraph" title="Permalink to this headline"></a></h3>
<p>道路图的实现在”road_graph.h”和”road_graph.cc”中，构建道路图在”BuildLaneGraph”方法中，而主要的实现则在”ConstructLaneSequence”中：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">RoadGraph::ConstructLaneSequence</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">search_forward_direction</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">accumulated_s</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_lane_seg_s</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">LaneInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lane_info_ptr</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">graph_search_horizon</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">consider_lane_split</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">LaneSegment</span><span class="o">&gt;*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">lane_segments</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">LaneGraph</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">lane_graph_ptr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Sanity checks.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_info_ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Invalid lane.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">graph_search_horizon</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;The lane search has already reached the limits&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Possible map error found!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Create a new lane_segment based on the current lane_info_ptr.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_s</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_lane_seg_s</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">curr_lane_seg_s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">total_length</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">LaneSegment</span><span class="w"> </span><span class="n">lane_segment</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_adc_s</span><span class="p">(</span><span class="n">curr_s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_lane_id</span><span class="p">(</span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">().</span><span class="n">id</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_lane_turn_type</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">PredictionMap</span><span class="o">::</span><span class="n">LaneTurnType</span><span class="p">(</span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">().</span><span class="n">id</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_total_length</span><span class="p">(</span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">total_length</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">search_forward_direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_start_s</span><span class="p">(</span><span class="n">curr_s</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_end_s</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fmin</span><span class="p">(</span><span class="n">curr_s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">length_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">accumulated_s</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">total_length</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_start_s</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">curr_s</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">length_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">accumulated_s</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segment</span><span class="p">.</span><span class="n">set_end_s</span><span class="p">(</span><span class="n">curr_s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">search_forward_direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segments</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lane_segment</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segments</span><span class="o">-&gt;</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lane_segment</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// End condition: if search reached the maximum search distance,</span>
<span class="w">  </span><span class="c1">// or if there is no more successor lane_segment.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">search_forward_direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_segment</span><span class="p">.</span><span class="n">end_s</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">total_length</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">        </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">successor_id</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">LaneSequence</span><span class="o">*</span><span class="w"> </span><span class="n">sequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lane_graph_ptr</span><span class="o">-&gt;</span><span class="n">add_lane_sequence</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">lane_segments</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="p">(</span><span class="n">sequence</span><span class="o">-&gt;</span><span class="n">add_lane_segment</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_segments</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_segment</span><span class="p">.</span><span class="n">start_s</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">        </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">predecessor_id</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">LaneSequence</span><span class="o">*</span><span class="w"> </span><span class="n">sequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lane_graph_ptr</span><span class="o">-&gt;</span><span class="n">add_lane_sequence</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">lane_segments</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="p">(</span><span class="n">sequence</span><span class="o">-&gt;</span><span class="n">add_lane_segment</span><span class="p">())</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">lane_segments</span><span class="o">-&gt;</span><span class="n">pop_front</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Otherwise, continue searching for subsequent lane_segments.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">new_accumulated_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">new_lane_seg_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">hdmap</span><span class="o">::</span><span class="n">LaneInfo</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">candidate_lanes</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">set_lane_ids</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">search_forward_direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">new_accumulated_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accumulated_s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">total_length</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">curr_s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Reundancy removal.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">successor_lane_id</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">successor_id</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">set_lane_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">successor_lane_id</span><span class="p">.</span><span class="n">id</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unique_id</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set_lane_ids</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">candidate_lanes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PredictionMap</span><span class="o">::</span><span class="n">LaneById</span><span class="p">(</span><span class="n">unique_id</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Sort the successor lane_segments from left to right.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">candidate_lanes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">candidate_lanes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">IsAtLeft</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Based on other conditions, select what successor lanes should be used.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">consider_lane_split</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">candidate_lanes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">PredictionMap</span><span class="o">::</span><span class="n">LaneWithSmallestAverageCurvature</span><span class="p">(</span><span class="n">candidate_lanes</span><span class="p">)};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">new_accumulated_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accumulated_s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">curr_s</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">new_lane_seg_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-0.1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Redundancy removal.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">predecessor_lane_id</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="w">         </span><span class="n">lane_info_ptr</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">predecessor_id</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">set_lane_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">predecessor_lane_id</span><span class="p">.</span><span class="n">id</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unique_id</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set_lane_ids</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">candidate_lanes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PredictionMap</span><span class="o">::</span><span class="n">LaneById</span><span class="p">(</span><span class="n">unique_id</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">consider_further_lane_split</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">search_forward_direction</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">FLAGS_prediction_offline_mode</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">       </span><span class="n">PredictionConstants</span><span class="o">::</span><span class="n">kDumpFeatureProto</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">FLAGS_prediction_offline_mode</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">       </span><span class="n">PredictionConstants</span><span class="o">::</span><span class="n">kDumpDataForLearning</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">consider_lane_split</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">candidate_lanes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Recursively expand lane-sequence.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">candidate_lane</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">candidate_lanes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ConstructLaneSequence</span><span class="p">(</span><span class="n">search_forward_direction</span><span class="p">,</span><span class="w"> </span><span class="n">new_accumulated_s</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">new_lane_seg_s</span><span class="p">,</span><span class="w"> </span><span class="n">candidate_lane</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">graph_search_horizon</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">consider_further_lane_split</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">lane_segments</span><span class="p">,</span><span class="w"> </span><span class="n">lane_graph_ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">search_forward_direction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segments</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_segments</span><span class="o">-&gt;</span><span class="n">pop_front</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述道路图的作用是什么？？？如何构造道路图？？？</p>
</div>
</div>
<div class="section" id="scenario">
<h2><span class="section-number">15.6. </span>场景(scenario)<a class="headerlink" href="#scenario" title="Permalink to this headline"></a></h2>
<p>根据本车的位置，和高精度地图，解析当前车辆所在的场景。</p>
<div class="section" id="scenariomanager">
<h3><span class="section-number">15.6.1. </span>场景管理器(ScenarioManager)<a class="headerlink" href="#scenariomanager" title="Permalink to this headline"></a></h3>
<p>场景管理器只有2个函数，一个是Run，一个是输出当前场景scenario。下面我们分析如何获取当前场景：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">ScenarioManager</span><span class="p">::</span><span class="n">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">获取环境特征</span>
  <span class="n">auto</span> <span class="n">environment_features</span> <span class="o">=</span> <span class="n">FeatureExtractor</span><span class="p">::</span><span class="n">ExtractEnvironmentFeatures</span><span class="p">();</span>
  <span class="o">//</span> <span class="n">通过环境特征分析场景</span>
  <span class="n">auto</span> <span class="n">ptr_scenario_features</span> <span class="o">=</span> <span class="n">ScenarioAnalyzer</span><span class="p">::</span><span class="n">Analyze</span><span class="p">(</span><span class="n">environment_features</span><span class="p">);</span>
  <span class="o">//</span> <span class="n">给当前场景赋值</span>
  <span class="n">current_scenario_</span> <span class="o">=</span> <span class="n">ptr_scenario_features</span><span class="o">-&gt;</span><span class="n">scenario</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">TODO</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span> <span class="n">other</span> <span class="n">functionalities</span> <span class="n">including</span> <span class="n">lane</span><span class="p">,</span> <span class="n">junction</span> <span class="n">filters</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="evaluator">
<h2><span class="section-number">15.7. </span>评估者(evaluator)<a class="headerlink" href="#evaluator" title="Permalink to this headline"></a></h2>
<p>“Evaluator”类为基类，其它类继承至该类，而”EvaluatorManager”类做为管理类，负责管理三种评估者，分别为：自行车，行人，汽车。</p>
<div class="section" id="id6">
<h3><span class="section-number">15.7.1. </span>评估者基类(Evaluator)<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h3>
<p>在”Evaluator”基类中申明方法”Evaluate”，其它子类重新构造实现了上述方法。另外基类中还实现了2个辅助函数：</p>
<ol class="arabic simple">
<li><p>提供世界坐标到物体坐标转换</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">&gt;</span> <span class="n">WorldCoordToObjCoord</span><span class="p">(</span>
      <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">&gt;</span> <span class="n">input_world_coord</span><span class="p">,</span>
      <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="o">&gt;</span> <span class="n">obj_world_coord</span><span class="p">,</span> <span class="n">double</span> <span class="n">obj_world_angle</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>提供向量转矩阵？？？</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Eigen</span><span class="p">::</span><span class="n">MatrixXf</span> <span class="n">VectorToMatrixXf</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="nb">int</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">end_index</span><span class="p">)</span>

  <span class="n">Eigen</span><span class="p">::</span><span class="n">MatrixXf</span> <span class="n">VectorToMatrixXf</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="nb">int</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">end_index</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="nb">int</span> <span class="n">output_num_row</span><span class="p">,</span>
                                   <span class="n">const</span> <span class="nb">int</span> <span class="n">output_num_col</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="evaluatormanager">
<h3><span class="section-number">15.7.2. </span>评估者管理器(EvaluatorManager)<a class="headerlink" href="#evaluatormanager" title="Permalink to this headline"></a></h3>
<p>评估者管理器主要是对评估器进行管理和注册。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EvaluatorManager</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>

  <span class="n">virtual</span> <span class="o">~</span><span class="n">EvaluatorManager</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>

  <span class="n">void</span> <span class="n">Init</span><span class="p">(</span><span class="n">const</span> <span class="n">PredictionConf</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">);</span>

  <span class="n">Evaluator</span><span class="o">*</span> <span class="n">GetEvaluator</span><span class="p">(</span><span class="n">const</span> <span class="n">ObstacleConf</span><span class="p">::</span><span class="n">EvaluatorType</span><span class="o">&amp;</span> <span class="nb">type</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">Run</span><span class="p">(</span><span class="n">ObstaclesContainer</span><span class="o">*</span> <span class="n">obstacles_container</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">EvaluateObstacle</span><span class="p">(</span><span class="n">Obstacle</span><span class="o">*</span> <span class="n">obstacle</span><span class="p">,</span>
                        <span class="n">ObstaclesContainer</span><span class="o">*</span> <span class="n">obstacles_container</span><span class="p">,</span>
                        <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Obstacle</span><span class="o">*&gt;</span> <span class="n">dynamic_env</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">EvaluateObstacle</span><span class="p">(</span><span class="n">Obstacle</span><span class="o">*</span> <span class="n">obstacle</span><span class="p">,</span>
                        <span class="n">ObstaclesContainer</span><span class="o">*</span> <span class="n">obstacles_container</span><span class="p">);</span>

 <span class="n">private</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">BuildObstacleIdHistoryMap</span><span class="p">(</span><span class="n">ObstaclesContainer</span><span class="o">*</span> <span class="n">obstacles_container</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">DumpCurrentFrameEnv</span><span class="p">(</span><span class="n">ObstaclesContainer</span><span class="o">*</span> <span class="n">obstacles_container</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">RegisterEvaluator</span><span class="p">(</span><span class="n">const</span> <span class="n">ObstacleConf</span><span class="p">::</span><span class="n">EvaluatorType</span><span class="o">&amp;</span> <span class="nb">type</span><span class="p">);</span>

  <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Evaluator</span><span class="o">&gt;</span> <span class="n">CreateEvaluator</span><span class="p">(</span>
      <span class="n">const</span> <span class="n">ObstacleConf</span><span class="p">::</span><span class="n">EvaluatorType</span><span class="o">&amp;</span> <span class="nb">type</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">RegisterEvaluators</span><span class="p">();</span>

 <span class="n">private</span><span class="p">:</span>
  <span class="n">std</span><span class="p">::</span><span class="nb">map</span><span class="o">&lt;</span><span class="n">ObstacleConf</span><span class="p">::</span><span class="n">EvaluatorType</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Evaluator</span><span class="o">&gt;&gt;</span> <span class="n">evaluators_</span><span class="p">;</span>
  <span class="o">...</span>

  <span class="n">std</span><span class="p">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">ObstacleHistory</span><span class="o">&gt;</span> <span class="n">obstacle_id_history_map_</span><span class="p">;</span>

  <span class="n">DECLARE_SINGLETON</span><span class="p">(</span><span class="n">EvaluatorManager</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>下面我们分别查看3种不同的评估者： 自行车评估者，行人评估者和车辆评估者。</p>
</div>
<div class="section" id="cyclistkeeplaneevaluator">
<h3><span class="section-number">15.7.3. </span>自行车评估者(CyclistKeepLaneEvaluator)<a class="headerlink" href="#cyclistkeeplaneevaluator" title="Permalink to this headline"></a></h3>
<p>自行车评估者主要是评估自行车保持当前车道的概率。评估主要是函数”Evaluate”中进行的，<strong>函数的参数”obstacles_container”没有使用，使用的只是”obstacle_ptr”障碍物指针</strong>。评估的过程主要是根据生成的”LaneGraph”计算自行车在lane中出现的概率。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">CyclistKeepLaneEvaluator::Evaluate</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">Obstacle</span><span class="o">*</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">ObstaclesContainer</span><span class="o">*</span><span class="w"> </span><span class="n">obstacles_container</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 设置评估者类型</span>
<span class="w">  </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">SetEvaluatorType</span><span class="p">(</span><span class="n">evaluator_type_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 特征是否初始化，该方法为protobuf自带方法，确认required字段是否都已经赋值，看起来这里没必要判断？？？</span>
<span class="w">  </span><span class="c1">// https://github.com/protocolbuffers/protobuf/issues/2900</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">latest_feature</span><span class="p">().</span><span class="n">IsInitialized</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">Feature</span><span class="o">*</span><span class="w"> </span><span class="n">latest_feature_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">mutable_latest_feature</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 检查特征是否包含lane graph</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">has_lane</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">has_lane_graph</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">has_lane_feature</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">LaneGraph</span><span class="o">*</span><span class="w"> </span><span class="n">lane_graph_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">mutable_lane</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mutable_lane_graph</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 检查lane graph的道路序列是否为空</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_graph_ptr</span><span class="o">-&gt;</span><span class="n">lane_sequence</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">curr_lane_id</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">lane</span><span class="p">().</span><span class="n">lane_feature</span><span class="p">().</span><span class="n">lane_id</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 计算每个lane序列的概率</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lane_sequence</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">lane_graph_ptr</span><span class="o">-&gt;</span><span class="n">mutable_lane_sequence</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">probability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeProbability</span><span class="p">(</span><span class="n">curr_lane_id</span><span class="p">,</span><span class="w"> </span><span class="n">lane_sequence</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lane_sequence</span><span class="p">.</span><span class="n">set_probability</span><span class="p">(</span><span class="n">probability</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>下面我们看下概率计算是如何进行的？计算的过程也很简单，就是判断lane序列的第一条lane是否和当前lane相同，相同则返回1，不相同则返回0。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>double CyclistKeepLaneEvaluator::ComputeProbability(
    const std::string&amp; curr_lane_id, const LaneSequence&amp; lane_sequence) {
  if (lane_sequence.lane_segment().empty()) {
    AWARN &lt;&lt; &quot;Empty lane sequence.&quot;;
    return 0.0;
  }
  // 如果序列的第一条车道和当前车道id一致，那么则返回1，否则返回0
  std::string lane_seq_first_id = lane_sequence.lane_segment(0).lane_id();
  if (curr_lane_id == lane_seq_first_id) {
    return 1.0;
  }
  return 0.0;
}
</pre></div>
</div>
</div>
<div class="section" id="pedestrianinteractionevaluator">
<h3><span class="section-number">15.7.4. </span>行人互动评估者(PedestrianInteractionEvaluator)<a class="headerlink" href="#pedestrianinteractionevaluator" title="Permalink to this headline"></a></h3>
<p>行人互动评估主要是估计行人的概率，采用了深度学习的LSTM模型，关于行人预测可以参考论文”Social LSTM:Human Trajectory Prediction in Crowded Spaces”，这里我们对代码进行分析。</p>
<ol class="arabic simple">
<li><p>首先初始化加载深度学习模型。</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">PedestrianInteractionEvaluator::LoadModel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 设置线程数为1</span>
<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">set_num_threads</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FLAGS_use_cuda</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">is_available</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CUDA is available&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 设置CUDA设备</span>
<span class="w">    </span><span class="n">device_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">Device</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">kCUDA</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 加载训练好的LTSM模型文件</span>
<span class="w">  </span><span class="n">torch_position_embedding_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">FLAGS_torch_pedestrian_interaction_position_embedding_file</span><span class="p">,</span><span class="w"> </span><span class="n">device_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">torch_social_embedding_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">FLAGS_torch_pedestrian_interaction_social_embedding_file</span><span class="p">,</span><span class="w"> </span><span class="n">device_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">torch_single_lstm_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">FLAGS_torch_pedestrian_interaction_single_lstm_file</span><span class="p">,</span><span class="w"> </span><span class="n">device_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">torch_prediction_layer_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">FLAGS_torch_pedestrian_interaction_prediction_layer_file</span><span class="p">,</span><span class="w"> </span><span class="n">device_</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>评估行人行为，函数比较长，输入为障碍物，输出为行人轨迹”latest_feature_ptr-&gt;add_predicted_trajectory”，关于Feature的描述在”feature.proto”中。其中函数参数”obstacles_container”没有使用（原因为继承至基类的方法，重写的时候保存了参数），下面我们开始分析具体的代码：</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">PedestrianInteractionEvaluator::Evaluate</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">Obstacle</span><span class="o">*</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">ObstaclesContainer</span><span class="o">*</span><span class="w"> </span><span class="n">obstacles_container</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Sanity checks.</span>
<span class="w">  </span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">obstacle_ptr</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">SetEvaluatorType</span><span class="p">(</span><span class="n">evaluator_type_</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">latest_feature</span><span class="p">().</span><span class="n">IsInitialized</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Obstacle [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] has no latest feature.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">Feature</span><span class="o">*</span><span class="w"> </span><span class="n">latest_feature_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">mutable_latest_feature</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">latest_feature_ptr</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Extract features, and:</span>
<span class="w">  </span><span class="c1">//  - if in offline mode, save it locally for training.</span>
<span class="w">  </span><span class="c1">//  - if in online mode, pass it through trained model to evaluate.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">feature_values</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 这里只是把最新的行人时间戳和位置提取出来了，并且线性存储在数组中(把数据展开)，</span>
<span class="w">  </span><span class="c1">// 也就是说数组的第一个元素是时间戳，第二为ID，第三和第四为位置。</span>
<span class="w">  </span><span class="n">ExtractFeatures</span><span class="p">(</span><span class="n">obstacle_ptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">feature_values</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FLAGS_prediction_offline_mode</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">      </span><span class="n">PredictionConstants</span><span class="o">::</span><span class="n">kDumpDataForLearning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FeatureOutput</span><span class="o">::</span><span class="n">InsertDataForLearning</span><span class="p">(</span><span class="o">*</span><span class="n">latest_feature_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">feature_values</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="s">&quot;pedestrian&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Saving extracted features for learning locally.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kShortTermPredictionTimeResolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kShortTermPredictionPointNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kHiddenStateUpdateCycle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Step 1 Get social embedding</span>
<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">social_pooling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSocialPooling</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">IValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">social_embedding_inputs</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">social_embedding_inputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">social_pooling</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">device_</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">social_embedding</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">torch_social_embedding_</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">social_embedding_inputs</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">toTensor</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">kCPU</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Step 2 Get position embedding</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">pos_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">feature_values</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">pos_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">feature_values</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">rel_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">rel_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">history_size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">kHiddenStateUpdateCycle</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">rel_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">latest_feature</span><span class="p">().</span><span class="n">position</span><span class="p">().</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">            </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">position</span><span class="p">().</span><span class="n">x</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">rel_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">latest_feature</span><span class="p">().</span><span class="n">position</span><span class="p">().</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">            </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">position</span><span class="p">().</span><span class="n">y</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">torch_position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">zeros</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="n">torch_position</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rel_x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">torch_position</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rel_y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">IValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">position_embedding_inputs</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">position_embedding_inputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">torch_position</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">device_</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">position_embedding</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">torch_position_embedding_</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">position_embedding_inputs</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">toTensor</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">kCPU</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Step 3 Conduct single LSTM and update hidden states</span>
<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">lstm_input</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">torch</span><span class="o">::</span><span class="n">zeros</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">kEmbeddingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="p">)});</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kEmbeddingSize</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lstm_input</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position_embedding</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"></span>
<span class="w">      </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ht</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">zeros</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">zeros</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_ptr</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">frame_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">curr_ht</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ht</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">curr_ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ct</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">curr_frame_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">frame_count</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_frame_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">kHiddenStateUpdateCycle</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">lstm_input</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">kEmbeddingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_ht</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">lstm_input</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">kEmbeddingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_ct</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">IValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lstm_inputs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lstm_inputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lstm_input</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">device_</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lstm_out_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch_single_lstm_</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">lstm_inputs</span><span class="p">).</span><span class="n">toTuple</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ht</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lstm_out_tuple</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">toTensor</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lstm_out_tuple</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">()[</span><span class="mi">1</span><span class="p">].</span><span class="n">toTensor</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ht</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ht</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ct</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">frame_count</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">curr_frame_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">kHiddenStateUpdateCycle</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Step 4 for-loop get a trajectory</span>
<span class="w">  </span><span class="c1">// Set the starting trajectory point</span>
<span class="w">  </span><span class="n">Trajectory</span><span class="o">*</span><span class="w"> </span><span class="n">trajectory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">add_predicted_trajectory</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">trajectory</span><span class="o">-&gt;</span><span class="n">set_probability</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">TrajectoryPoint</span><span class="o">*</span><span class="w"> </span><span class="n">start_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trajectory</span><span class="o">-&gt;</span><span class="n">add_trajectory_point</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">start_point</span><span class="o">-&gt;</span><span class="n">mutable_path_point</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_x</span><span class="p">(</span><span class="n">pos_x</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">start_point</span><span class="o">-&gt;</span><span class="n">mutable_path_point</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_y</span><span class="p">(</span><span class="n">pos_y</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">start_point</span><span class="o">-&gt;</span><span class="n">mutable_path_point</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_theta</span><span class="p">(</span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">theta</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">start_point</span><span class="o">-&gt;</span><span class="n">set_v</span><span class="p">(</span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">start_point</span><span class="o">-&gt;</span><span class="n">set_relative_time</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">kShortTermPredictionPointNum</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">prev_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trajectory</span><span class="o">-&gt;</span><span class="n">trajectory_point</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">path_point</span><span class="p">().</span><span class="n">x</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">prev_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trajectory</span><span class="o">-&gt;</span><span class="n">trajectory_point</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">path_point</span><span class="p">().</span><span class="n">y</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">CHECK</span><span class="p">(</span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"></span>
<span class="w">          </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">torch_position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch</span><span class="o">::</span><span class="n">zeros</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_rel_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rel_x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_rel_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rel_y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_rel_x</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">prev_x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">trajectory</span><span class="o">-&gt;</span><span class="n">trajectory_point</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">path_point</span><span class="p">().</span><span class="n">x</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_rel_y</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">prev_y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">trajectory</span><span class="o">-&gt;</span><span class="n">trajectory_point</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">path_point</span><span class="p">().</span><span class="n">y</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">torch_position</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_rel_x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">torch_position</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_rel_y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">IValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">position_embedding_inputs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">position_embedding_inputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">torch_position</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">device_</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">position_embedding</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">torch_position_embedding_</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">position_embedding_inputs</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">toTensor</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">kCPU</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">lstm_input</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">torch</span><span class="o">::</span><span class="n">zeros</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">kEmbeddingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kEmbeddingSize</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">lstm_input</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position_embedding</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ht</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ht</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obstacle_id_lstm_state_map_</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ct</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">lstm_input</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">kEmbeddingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">lstm_input</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">kEmbeddingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kHiddenSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ct</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">IValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lstm_inputs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lstm_inputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lstm_input</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">device_</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lstm_out_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch_single_lstm_</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">lstm_inputs</span><span class="p">).</span><span class="n">toTuple</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">ht</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lstm_out_tuple</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">toTensor</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lstm_out_tuple</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">()[</span><span class="mi">1</span><span class="p">].</span><span class="n">toTensor</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">jit</span><span class="o">::</span><span class="n">IValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">prediction_inputs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">prediction_inputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">pred_out_tensor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torch_prediction_layer_</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">prediction_inputs</span><span class="p">)</span><span class="w"></span>
<span class="w">                               </span><span class="p">.</span><span class="n">toTensor</span><span class="p">()</span><span class="w"></span>
<span class="w">                               </span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">::</span><span class="n">kCPU</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">pred_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pred_out_tensor</span><span class="p">.</span><span class="n">accessor</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">TrajectoryPoint</span><span class="o">*</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trajectory</span><span class="o">-&gt;</span><span class="n">add_trajectory_point</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev_x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred_out</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">curr_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev_y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred_out</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">point</span><span class="o">-&gt;</span><span class="n">mutable_path_point</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_x</span><span class="p">(</span><span class="n">curr_x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">point</span><span class="o">-&gt;</span><span class="n">mutable_path_point</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_y</span><span class="p">(</span><span class="n">curr_y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">point</span><span class="o">-&gt;</span><span class="n">set_v</span><span class="p">(</span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">point</span><span class="o">-&gt;</span><span class="n">mutable_path_point</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_theta</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">latest_feature_ptr</span><span class="o">-&gt;</span><span class="n">velocity_heading</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">point</span><span class="o">-&gt;</span><span class="n">set_relative_time</span><span class="p">(</span><span class="n">kShortTermPredictionTimeResolution</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                             </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>车辆评估者涉及的评估者模型比较多，下面我们逐个介绍。</p>
</div>
<div class="section" id="costevaluator">
<h3><span class="section-number">15.7.5. </span>CostEvaluator<a class="headerlink" href="#costevaluator" title="Permalink to this headline"></a></h3>
<p>评估车辆的横向偏移概率，通过计算当前车的宽度和车道的横向差值，然后通过”Sigmoid”函数映射到0-1的概率空间。</p>
</div>
<div class="section" id="cruisemlpevaluator">
<h3><span class="section-number">15.7.6. </span>CruiseMLPEvaluator<a class="headerlink" href="#cruisemlpevaluator" title="Permalink to this headline"></a></h3>
<p>MLP为”多层神经网络”，相比上述过程，新增加了lane相关的特征。</p>
</div>
<div class="section" id="junctionmapevaluator">
<h3><span class="section-number">15.7.7. </span>JunctionMapEvaluator<a class="headerlink" href="#junctionmapevaluator" title="Permalink to this headline"></a></h3>
<p>加入了语义地图，模型未知？？？</p>
</div>
<div class="section" id="junctionmlpevaluator">
<h3><span class="section-number">15.7.8. </span>JunctionMLPEvaluator<a class="headerlink" href="#junctionmlpevaluator" title="Permalink to this headline"></a></h3>
<p>路口多层神经网络，没有利用地图</p>
</div>
<div class="section" id="laneaggregatingevaluator">
<h3><span class="section-number">15.7.9. </span>LaneAggregatingEvaluator<a class="headerlink" href="#laneaggregatingevaluator" title="Permalink to this headline"></a></h3>
<p>道路合并评估器</p>
</div>
<div class="section" id="lanescanningevaluator">
<h3><span class="section-number">15.7.10. </span>LaneScanningEvaluator<a class="headerlink" href="#lanescanningevaluator" title="Permalink to this headline"></a></h3>
<p>道路扫描？？？</p>
</div>
<div class="section" id="mlpevaluator">
<h3><span class="section-number">15.7.11. </span>MLPEvaluator<a class="headerlink" href="#mlpevaluator" title="Permalink to this headline"></a></h3>
<p>多层神经网络评估器？？？</p>
</div>
<div class="section" id="semanticlstmevaluator">
<h3><span class="section-number">15.7.12. </span>SemanticLSTMEvaluator<a class="headerlink" href="#semanticlstmevaluator" title="Permalink to this headline"></a></h3>
<p>语义LSTM评估器</p>
<p>评估器主要是用深度学习的方法进行预测对应的概率，而且依赖事先建好的图，所以弄清楚上述2个过程很关键。</p>
</div>
</div>
<div class="section" id="predictor">
<h2><span class="section-number">15.8. </span>预测器(predictor)<a class="headerlink" href="#predictor" title="Permalink to this headline"></a></h2>
<p>“Predictor”类为基类，其它类继承至该类，而”PredictorManager”类作为管理类。最后通过预测器预测障碍物的轨迹。</p>
<div class="section" id="id7">
<h3><span class="section-number">15.8.1. </span>预测器基类(Predictor)<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h3>
<p>预测者基类主要申明了”Predict”方法，在子预测器中重构。输入是评估器给出的概率(trajectory)，输出则是预测的轨迹。</p>
</div>
<div class="section" id="predictormanager">
<h3><span class="section-number">15.8.2. </span>预测管理器(PredictorManager)<a class="headerlink" href="#predictormanager" title="Permalink to this headline"></a></h3>
<p>预测管理器主要是对预测器进行创建，管理和注册。主要的实现在”PredictObstacle”中：</p>
<p>下面我们分别介绍几种预测器。</p>
</div>
<div class="section" id="emptypredictor">
<h3><span class="section-number">15.8.3. </span>EmptyPredictor<a class="headerlink" href="#emptypredictor" title="Permalink to this headline"></a></h3>
<p>对静止的物体进行预测，没有任何轨迹输出。</p>
</div>
<div class="section" id="extrapolationpredictor">
<h3><span class="section-number">15.8.4. </span>ExtrapolationPredictor<a class="headerlink" href="#extrapolationpredictor" title="Permalink to this headline"></a></h3>
<p>外推法预测器，</p>
</div>
<div class="section" id="freemovepredictor">
<h3><span class="section-number">15.8.5. </span>FreeMovePredictor<a class="headerlink" href="#freemovepredictor" title="Permalink to this headline"></a></h3>
<p>自由移动？？？</p>
</div>
<div class="section" id="interactionpredictor">
<h3><span class="section-number">15.8.6. </span>InteractionPredictor<a class="headerlink" href="#interactionpredictor" title="Permalink to this headline"></a></h3>
</div>
<div class="section" id="junctionpredictor">
<h3><span class="section-number">15.8.7. </span>JunctionPredictor<a class="headerlink" href="#junctionpredictor" title="Permalink to this headline"></a></h3>
</div>
<div class="section" id="lanesequencepredictor">
<h3><span class="section-number">15.8.8. </span>LaneSequencePredictor<a class="headerlink" href="#lanesequencepredictor" title="Permalink to this headline"></a></h3>
<p>生成曲线在”DrawLaneSequenceTrajectoryPoints”中实现。</p>
</div>
<div class="section" id="movesequencepredictor">
<h3><span class="section-number">15.8.9. </span>MoveSequencePredictor<a class="headerlink" href="#movesequencepredictor" title="Permalink to this headline"></a></h3>
</div>
<div class="section" id="sequencepredictor">
<h3><span class="section-number">15.8.10. </span>SequencePredictor<a class="headerlink" href="#sequencepredictor" title="Permalink to this headline"></a></h3>
</div>
<div class="section" id="singlelanepredictor">
<h3><span class="section-number">15.8.11. </span>SingleLanePredictor<a class="headerlink" href="#singlelanepredictor" title="Permalink to this headline"></a></h3>
<p>上述所有评估器的过程都类似，都是找到lane之后对lane做一个平滑的曲线？？？最后都调用了”PredictionMap::SmoothPointFromLane”。</p>
</div>
</div>
<div class="section" id="reference">
<h2><span class="section-number">15.9. </span>Reference<a class="headerlink" href="#reference" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://www.cnblogs.com/liuzubing/p/11388485.html">Apollo 5.0 障碍物行为预测技术</a></p></li>
<li><p><a class="reference external" href="https://cloud.tencent.com/developer/news/310036">Apollo自动驾驶入门课程第⑥讲—预测</a></p></li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../planning/readme.html" class="btn btn-neutral float-left" title="14. Planning" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../routing/readme.html" class="btn btn-neutral float-right" title="16. Routing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, daohu527.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>