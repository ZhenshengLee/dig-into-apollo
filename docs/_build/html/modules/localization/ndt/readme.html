<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dig into Apollo - Localization &mdash; dig-into-apollo  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> dig-into-apollo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../what_is_apollo/readme.html">Dig into Apollo - Introduction </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cyber/readme.html">Dig into Apollo - Cyber </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docker/readme.html">Dig into Apollo - Docker </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../library/readme.html">Dig into Apollo - Library </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../papers/readme.html">Dig into Apollo - Papers </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance/readme.html">Dig into Apollo - Performance </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../questions/readme.html">Dig into Apollo - Questions </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../simulation/readme.html">Dig into Apollo - Simulation </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to_build/readme.html">Dig into Apollo - Build </a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">dig-into-apollo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Dig into Apollo - Localization </li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/modules/localization/ndt/readme.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="dig-into-apollo-localization-github">
<h1>Dig into Apollo - Localization <img alt="GitHub" src="https://img.shields.io/github/license/daohu527/Dig-into-Apollo.svg?style=popout" /><a class="headerlink" href="#dig-into-apollo-localization-github" title="Permalink to this headline"></a></h1>
<div class="section" id="map-creation">
<h2>map_creation<a class="headerlink" href="#map-creation" title="Permalink to this headline"></a></h2>
<p>加载pcd pose文件</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">apollo</span><span class="o">::</span><span class="n">localization</span><span class="o">::</span><span class="n">msf</span><span class="o">::</span><span class="n">velodyne</span><span class="o">::</span><span class="n">LoadPcdPoses</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">pose_files</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pcd_poses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">time_stamps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pcd_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="ndt">
<h2>创建NDT地图<a class="headerlink" href="#ndt" title="Permalink to this headline"></a></h2>
<p>创建ndt地图</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">apollo</span><span class="o">::</span><span class="n">localization</span><span class="o">::</span><span class="n">msf</span><span class="o">::</span><span class="n">pyramid_map</span><span class="o">::</span><span class="n">NdtMap</span><span class="w"></span>
<span class="n">apollo</span><span class="o">::</span><span class="n">localization</span><span class="o">::</span><span class="n">msf</span><span class="o">::</span><span class="n">pyramid_map</span><span class="o">::</span><span class="n">NdtMapNodePool</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h2>平面提取<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">apollo</span><span class="o">::</span><span class="n">localization</span><span class="o">::</span><span class="n">msf</span><span class="o">::</span><span class="n">FeatureXYPlane</span><span class="w"></span>
</pre></div>
</div>
<p>下面主要介绍一下local_map中的base_map</p>
</div>
<div class="section" id="base-map">
<h2>base_map<a class="headerlink" href="#base-map" title="Permalink to this headline"></a></h2>
<div class="section" id="id2">
<h3>base_map<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h3>
<p>BaseMap中包括map_node_pool_，也就是说一些map_node_pool_缓存了一些map_node。因为加载map_node需要一些时间，因此采用了提前加载并且缓存的方式。map_node_cache_lvl1_和map_node_cache_lvl2_都是一个LRU的cache。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BaseMap</span><span class="o">::</span><span class="n">BaseMap</span><span class="p">(</span><span class="n">BaseMapConfig</span><span class="o">*</span><span class="w"> </span><span class="n">map_config</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">map_config_</span><span class="p">(</span><span class="n">map_config</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">map_node_cache_lvl1_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">map_node_cache_lvl2_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">map_node_pool_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>先从map_node_cache_lvl1_中获取map node，如果没有然后从map_node_cache_lvl2_中获取，并且存放到map_node_cache_lvl1_，如果都没有，则从磁盘中读取，磁盘中读取直接放入map_node_cache_lvl2_，然后放入map_node_cache_lvl1_并且返回。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BaseMapNode</span><span class="o">*</span> <span class="n">BaseMap</span><span class="p">::</span><span class="n">GetMapNodeSafe</span><span class="p">(</span><span class="n">const</span> <span class="n">MapNodeIndex</span><span class="o">&amp;</span> <span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>提前加载地图节点</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">BaseMap::PreloadMapNodes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">MapNodeIndex</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">map_ids</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">DCHECK_LE</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()),</span><span class="w"></span>
<span class="w">            </span><span class="n">map_node_cache_lvl2_</span><span class="o">-&gt;</span><span class="n">Capacity</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="c1">// check in cacheL2</span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">MapNodeIndex</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_exist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_node_cache_lvl2_</span><span class="o">-&gt;</span><span class="n">IsExist</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_exist</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// check whether in already preloading index set</span>
<span class="w">  </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">preloading_itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_preloading_task_index_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">preloading_itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_preloading_task_index_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preloading_itr</span><span class="w"> </span><span class="o">!=</span><span class="w"></span>
<span class="w">        </span><span class="n">map_preloading_task_index_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// already preloading</span>
<span class="w">      </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// load form disk sync</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">preload_futures</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Preload map node size: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Preload map node: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock3</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">map_preloading_task_index_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lock3</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">preload_futures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">cyber</span><span class="o">::</span><span class="n">Async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BaseMap</span><span class="o">::</span><span class="n">LoadMapNodeThreadSafety</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="o">++</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>加载地图节点</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">BaseMap::LoadMapNodes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">MapNodeIndex</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">map_ids</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 先在cacheL1中查找，如果找到则从map_ids删除找到的节点，最终剩下没有找到的节点</span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">MapNodeIndex</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map_node_cache_lvl1_</span><span class="o">-&gt;</span><span class="n">IsExist</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// std::cout &lt;&lt; &quot;LoadMapNodes find in L1 cache&quot; &lt;&lt; std::endl;</span>
<span class="w">      </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">map_node_cache_lvl2_</span><span class="o">-&gt;</span><span class="n">IsExist</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span><span class="w">  </span><span class="c1">// fresh lru list</span>
<span class="w">      </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 接着在cacheL2中查找，如果找到则从map_ids删除找到的节点，最终剩下没有找到的节点</span>
<span class="w">  </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">BaseMapNode</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map_node_cache_lvl2_</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// std::cout &lt;&lt; &quot;LoadMapNodes find in L2 cache&quot; &lt;&lt; std::endl;</span>
<span class="w">      </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">SetIsReserved</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">map_node_cache_lvl1_</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 并发从硬盘中加载map_id的节点</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">load_futures</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Preload map node failed!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">load_futures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">cyber</span><span class="o">::</span><span class="n">Async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BaseMap</span><span class="o">::</span><span class="n">LoadMapNodeThreadSafety</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="o">++</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">load_futures</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 然后查看cacheL2是否有对应的map_id的节点，上一步从硬盘中读取的map_node会先放入le_cache。</span>
<span class="w">  </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock2</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map_node_cache_lvl2_</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;LoadMapNodes: preload missed, load this node in main thread.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">SetIsReserved</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">map_node_cache_lvl1_</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">itr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">lock2</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 检查是否所有节点都已经加载，如果不是则报错</span>
<span class="w">  </span><span class="n">CHECK</span><span class="p">(</span><span class="n">map_ids</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>根据index从硬盘中加载地图，map_node_pool_和map_node_cache_lvl2_的关系是什么？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">BaseMap::LoadMapNodeThreadSafety</span><span class="p">(</span><span class="n">MapNodeIndex</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_reserved</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">BaseMapNode</span><span class="o">*</span><span class="w"> </span><span class="n">map_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">map_node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">map_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_node_pool_</span><span class="o">-&gt;</span><span class="n">AllocMapNode</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map_node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">BaseMapNode</span><span class="o">*</span><span class="w"> </span><span class="n">node_remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_node_cache_lvl2_</span><span class="o">-&gt;</span><span class="n">ClearOne</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_remove</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">map_node_pool_</span><span class="o">-&gt;</span><span class="n">FreeMapNode</span><span class="p">(</span><span class="n">node_remove</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 初始化map_node，并且加载</span>
<span class="w">  </span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">(</span><span class="n">map_config_</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">Load</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Created map node: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; Loaded map node: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">SetIsReserved</span><span class="p">(</span><span class="n">is_reserved</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 添加到map_node_cache_lvl2_</span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">map_load_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">BaseMapNode</span><span class="o">*</span><span class="w"> </span><span class="n">node_remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_node_cache_lvl2_</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">map_node</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// if the node already added into cacheL2, erase it from preloading set</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">itr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_preloading_task_index_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">itr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">map_preloading_task_index_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">map_preloading_task_index_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 在map_node_pool_中释放node_remove</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_remove</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">map_node_pool_</span><span class="o">-&gt;</span><span class="n">FreeMapNode</span><span class="p">(</span><span class="n">node_remove</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>提前加载地图区域</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">BaseMap::PreloadMapArea</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">trans_diff</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">resolution_id</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zone_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 四象限中的位置</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x_direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trans_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y_direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trans_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取地图的精度</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">MapNodeIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map_ids</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">map_pixel_resolution</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_resolutions_</span><span class="p">[</span><span class="n">resolution_id</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">/// 车的位置平移一个map_node的距离</span>
<span class="w">  </span><span class="c1">// 根据top_left, 查找map_id，其中resolution_id代表精度数组的编号</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">pt_top_left</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pt_top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_node_size_x_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                     </span><span class="n">map_pixel_resolution</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">pt_top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_node_size_y_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                     </span><span class="n">map_pixel_resolution</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">pt_top_left</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="n">MapNodeIndex</span><span class="w"> </span><span class="n">map_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MapNodeIndex</span><span class="o">::</span><span class="n">GetMapNodeIndex</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="p">),</span><span class="w"> </span><span class="n">pt_top_left</span><span class="p">,</span><span class="w"> </span><span class="n">resolution_id</span><span class="p">,</span><span class="w"> </span><span class="n">zone_id</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">map_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map_id</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 同时根据以下几个坐标，查找map_id</span>
<span class="w">  </span><span class="c1">/// top center</span>
<span class="w">  </span><span class="c1">/// top right</span>
<span class="w">  </span><span class="c1">/// middle left</span>
<span class="w">  </span><span class="c1">/// middle center</span>
<span class="w">  </span><span class="c1">/// middle right</span>
<span class="w">  </span><span class="c1">/// bottom left</span>
<span class="w">  </span><span class="c1">/// bottom center</span>
<span class="w">  </span><span class="c1">/// bottom right</span>

<span class="w">  </span><span class="c1">// 根据x_direction * 1.5，y_direction * 1.5和(x_direction * 1.5, y_direction * 1.5)</span>
<span class="w">  </span><span class="c1">// 查找map_id</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">pt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x_direction</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1.5</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                              </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_node_size_x_</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                              </span><span class="n">map_pixel_resolution</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                              </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_node_size_y_</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                              </span><span class="n">map_pixel_resolution</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">map_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MapNodeIndex</span><span class="o">::</span><span class="n">GetMapNodeIndex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">,</span><span class="w"></span>
<span class="w">                                           </span><span class="n">resolution_id</span><span class="p">,</span><span class="w"> </span><span class="n">zone_id</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">map_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map_id</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// y_direction * 1.5</span>
<span class="w">  </span><span class="c1">// (x_direction * 1.5, y_direction * 1.5)</span>

<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">PreloadMapNodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_ids</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>根据seed_pt3d的位置，加载地图区域</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">BaseMap::LoadMapArea</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">seed_pt3d</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">resolution_id</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zone_id</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">int</span><span class="w"> </span><span class="n">filter_size_x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">filter_size_y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">map_node_pool_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">MapNodeIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map_ids</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">map_pixel_resolution</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_resolutions_</span><span class="p">[</span><span class="n">resolution_id</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="c1">/// top left</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">pt_top_left</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pt_top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seed_pt3d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                   </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_node_size_x_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                    </span><span class="n">map_pixel_resolution</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                   </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">filter_size_x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map_pixel_resolution</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pt_top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seed_pt3d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                   </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="o">-&gt;</span><span class="n">map_node_size_y_</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                    </span><span class="n">map_pixel_resolution</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                   </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">filter_size_y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map_pixel_resolution</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pt_top_left</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MapNodeIndex</span><span class="w"> </span><span class="n">map_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MapNodeIndex</span><span class="o">::</span><span class="n">GetMapNodeIndex</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">map_config_</span><span class="p">),</span><span class="w"> </span><span class="n">pt_top_left</span><span class="p">,</span><span class="w"> </span><span class="n">resolution_id</span><span class="p">,</span><span class="w"> </span><span class="n">zone_id</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">map_ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map_id</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">/// top center</span>
<span class="w">  </span><span class="c1">/// top right</span>
<span class="w">  </span><span class="c1">/// middle left</span>
<span class="w">  </span><span class="c1">/// middle center</span>
<span class="w">  </span><span class="c1">/// middle right</span>
<span class="w">  </span><span class="c1">/// bottom left</span>
<span class="w">  </span><span class="c1">/// bottom center</span>
<span class="w">  </span><span class="c1">/// bottom right</span>

<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">LoadMapNodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_ids</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ndtmapnode">
<h2>NdtMapNode<a class="headerlink" href="#ndtmapnode" title="Permalink to this headline"></a></h2>
<p>NdtMapNode是地图的单元格，主要是用来确定无人车的位置，这里的x,y是相对node的位置，然后根据(x,y)的坐标转换为UTM的绝对位置。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="nf">NdtMapNode::GetCoordinate3D</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                                            </span><span class="kt">int</span><span class="w"> </span><span class="n">altitude_index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">left_top_corner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetLeftTopCorner</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="w"> </span><span class="n">coord_2d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">coord_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">left_top_corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GetMapResolution</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">coord_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">left_top_corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GetMapResolution</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">altitude</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">NdtMapCells</span><span class="o">::</span><span class="n">CalAltitude</span><span class="p">(</span><span class="n">GetMapResolutionZ</span><span class="p">(),</span><span class="w"> </span><span class="n">altitude_index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">coord_3d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">coord_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coord_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">coord_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coord_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">coord_3d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">altitude</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">coord_3d</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>同时还涉及2个Node节点如何做合并，这里主要是调用了NdtMapMatrix的合并方法。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">NdtMapNode::Reduce</span><span class="p">(</span><span class="n">NdtMapNode</span><span class="o">*</span><span class="w"> </span><span class="n">map_node</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">NdtMapNode</span><span class="o">&amp;</span><span class="w"> </span><span class="n">map_node_new</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">index_</span><span class="p">.</span><span class="n">m_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">map_node_new</span><span class="p">.</span><span class="n">index_</span><span class="p">.</span><span class="n">m_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">index_</span><span class="p">.</span><span class="n">n_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">map_node_new</span><span class="p">.</span><span class="n">index_</span><span class="p">.</span><span class="n">n_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">index_</span><span class="p">.</span><span class="n">resolution_id_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">map_node_new</span><span class="p">.</span><span class="n">index_</span><span class="p">.</span><span class="n">resolution_id_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">index_</span><span class="p">.</span><span class="n">zone_id_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">map_node_new</span><span class="p">.</span><span class="n">index_</span><span class="p">.</span><span class="n">zone_id_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">NdtMapMatrix</span><span class="o">::</span><span class="n">Reduce</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">NdtMapMatrix</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">map_node</span><span class="o">-&gt;</span><span class="n">map_matrix_</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">NdtMapMatrix</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">map_node_new</span><span class="p">.</span><span class="n">map_matrix_</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>NdtMapMatrix包含(m,n)的NdtMapCells矩阵，这里遍历合并2个矩阵。我们主要看下如何合并的逻辑</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">NdtMapMatrix::Reduce</span><span class="p">(</span><span class="n">NdtMapMatrix</span><span class="o">*</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">NdtMapMatrix</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cells_new</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cells</span><span class="o">-&gt;</span><span class="n">GetRows</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cells</span><span class="o">-&gt;</span><span class="n">GetCols</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">NdtMapCells</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cells</span><span class="o">-&gt;</span><span class="n">GetMapCell</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">NdtMapCells</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cells_new</span><span class="p">.</span><span class="n">GetMapCell</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">NdtMapCells</span><span class="o">::</span><span class="n">Reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="n">cell_new</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>最后合并2个NdtMapCells。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">NdtMapCells::Reduce</span><span class="p">(</span><span class="n">NdtMapCells</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">NdtMapCells</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell_new</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Reduce cells</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_new</span><span class="p">.</span><span class="n">cells_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cell_new</span><span class="p">.</span><span class="n">cells_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">altitude_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">got</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">altitude_index</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">got</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">[</span><span class="n">altitude_index</span><span class="p">].</span><span class="n">MergeCell</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">[</span><span class="n">altitude_index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NdtMapSingleCell</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cell_new</span><span class="p">.</span><span class="n">max_altitude_index_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">max_altitude_index_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">max_altitude_index_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_new</span><span class="p">.</span><span class="n">max_altitude_index_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cell_new</span><span class="p">.</span><span class="n">min_altitude_index_</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">min_altitude_index_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">min_altitude_index_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_new</span><span class="p">.</span><span class="n">min_altitude_index_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_new</span><span class="p">.</span><span class="n">road_cell_indices_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="n">it_new</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cell_new</span><span class="p">.</span><span class="n">road_cell_indices_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it_new</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">got_it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">road_cell_indices_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">                            </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">road_cell_indices_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">it_new</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">got_it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">road_cell_indices_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">*</span><span class="n">got_it</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">it_new</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">road_cell_indices_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">it_new</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="maptool">
<h2>maptool<a class="headerlink" href="#maptool" title="Permalink to this headline"></a></h2>
<p>异步保存地图</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">map_node_pool_</span><span class="o">-&gt;</span><span class="n">FreeMapNode</span><span class="p">(</span><span class="n">node_remove</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>介绍完了制作地图的过程，下面开始介绍NDT定位的过程。</p>
</div>
<div class="section" id="id3">
<h2>NDT定位模块<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2>
<p>NDTLocalizationComponent进行初始化，并且根据输入的gps消息结合点云信息输出定位和坐标translation关系。</p>
<div class="section" id="ndtlocalization">
<h3>NDTLocalization<a class="headerlink" href="#ndtlocalization" title="Permalink to this headline"></a></h3>
<p>定位的具体功能是在NDTLocalization中实现的。NDT的匹配在<code class="docutils literal notranslate"><span class="pre">lidar_locator_</span></code>中，而融合的部分在</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">lidar_locator_</span><span class="p">.</span><span class="n">IsInitialized</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lidar_locator_</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">odometry_pose</span><span class="p">,</span><span class="w"> </span><span class="n">resolution_id_</span><span class="p">,</span><span class="w"> </span><span class="n">zone_id_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">lidar_locator_</span><span class="p">.</span><span class="n">Update</span><span class="p">(</span><span class="n">frame_idx</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">odometry_pose</span><span class="p">,</span><span class="w"> </span><span class="n">lidar_frame</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">lidar_pose_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lidar_locator_</span><span class="p">.</span><span class="n">GetPose</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">pose_buffer_</span><span class="p">.</span><span class="n">UpdateLidarPose</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">,</span><span class="w"> </span><span class="n">lidar_pose_</span><span class="p">,</span><span class="w"> </span><span class="n">odometry_pose</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ComposeLidarResult</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">,</span><span class="w"> </span><span class="n">lidar_pose_</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lidar_localization_result_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ndt_score_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lidar_locator_</span><span class="p">.</span><span class="n">GetFitnessScore</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="localizationposebuffer">
<h3>LocalizationPoseBuffer<a class="headerlink" href="#localizationposebuffer" title="Permalink to this headline"></a></h3>
<p>LocalizationPoseBuffer是一个buffer，大小默认为20，会存储历史的lidar姿态和IMU姿态，然后根据当前的IMU姿态推断最新的lidar姿态。</p>
</div>
</div>
<div class="section" id="lidarlocatorndt">
<h2>LidarLocatorNdt<a class="headerlink" href="#lidarlocatorndt" title="Permalink to this headline"></a></h2>
<p>NDT定位的主要实现在LidarLocatorNdt模块中。 根据输入的pose然后再进行ndt匹配，这样在IMU有偏差的情况下，可以有一定程度的校准，如果长时间GPS和IMU的定位不准确，那么当前的方案可能就不太可行。另外这里没有尝试纯NDT定位的方案，如果需要测试纯NDT定位的效果，也需要修改部分代码才能实现。</p>
<p>主要的处理函数在<code class="docutils literal notranslate"><span class="pre">LidarLocatorNdt::Update</span></code>中实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">LidarLocatorNdt::Update</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">frame_idx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pose</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">LidarFrame</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lidar_frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Increasement from INSPVA</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">trans_diff</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">pose</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pre_input_location_</span><span class="p">.</span><span class="n">translation</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">trans_pre_local</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">pre_estimate_location_</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">trans_diff</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="w"> </span><span class="n">quatd</span><span class="p">(</span><span class="n">pose</span><span class="p">.</span><span class="n">linear</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Translation3d</span><span class="w"> </span><span class="n">transd</span><span class="p">(</span><span class="n">trans_pre_local</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="w"> </span><span class="n">center_pose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">quatd</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="w"> </span><span class="n">pose_qbn</span><span class="p">(</span><span class="n">pose</span><span class="p">.</span><span class="n">linear</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;original pose: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pose</span><span class="p">.</span><span class="n">translation</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pose</span><span class="p">.</span><span class="n">translation</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pose</span><span class="p">.</span><span class="n">translation</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pose_qbn</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pose_qbn</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pose_qbn</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pose_qbn</span><span class="p">.</span><span class="n">w</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Get lidar pose Twv = Twb * Tbv</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="w"> </span><span class="n">transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">center_pose</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">velodyne_extrinsic_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">predict_location_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">center_pose</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Pre-load the map nodes</span>
<span class="cp">#ifdef USE_PRELOAD_MAP_NODE</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">map_is_ready</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">map_</span><span class="p">.</span><span class="n">LoadMapArea</span><span class="p">(</span><span class="n">center_pose</span><span class="p">.</span><span class="n">translation</span><span class="p">(),</span><span class="w"> </span><span class="n">resolution_id_</span><span class="p">,</span><span class="w"> </span><span class="n">zone_id_</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">filter_x_</span><span class="p">,</span><span class="w"> </span><span class="n">filter_y_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">map_</span><span class="p">.</span><span class="n">PreloadMapArea</span><span class="p">(</span><span class="n">center_pose</span><span class="p">.</span><span class="n">translation</span><span class="p">(),</span><span class="w"> </span><span class="n">trans_diff</span><span class="p">,</span><span class="w"> </span><span class="n">resolution_id_</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">zone_id_</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="c1">// Online pointcloud are projected into a ndt map node. (filtered)</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">lt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pose</span><span class="p">.</span><span class="n">translation</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">lt_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pose</span><span class="p">.</span><span class="n">translation</span><span class="p">()[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">map_resolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_</span><span class="p">.</span><span class="n">GetConfig</span><span class="p">().</span><span class="n">map_resolutions_</span><span class="p">[</span><span class="n">resolution_id_</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">lt_x</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">GetConfig</span><span class="p">().</span><span class="n">map_node_size_x_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map_resolution</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">lt_y</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">GetConfig</span><span class="p">().</span><span class="n">map_node_size_y_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map_resolution</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Start Ndt method</span>
<span class="w">  </span><span class="c1">// Convert online points to pcl pointcloud</span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">time</span><span class="o">::</span><span class="n">Timer</span><span class="w"> </span><span class="n">online_filtered_timer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">online_filtered_timer</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">online_points</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lidar_frame</span><span class="p">.</span><span class="n">pt_xs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">lidar_frame</span><span class="p">.</span><span class="n">pt_xs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">lidar_frame</span><span class="p">.</span><span class="n">pt_ys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"></span>
<span class="w">                    </span><span class="n">lidar_frame</span><span class="p">.</span><span class="n">pt_zs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">online_points</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Filter online points</span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Online point cloud leaf size: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">proj_reslution_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">online_points_filtered</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">VoxelGrid</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sor</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">sor</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">online_points</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">sor</span><span class="p">.</span><span class="n">setLeafSize</span><span class="p">(</span><span class="n">proj_reslution_</span><span class="p">,</span><span class="w"> </span><span class="n">proj_reslution_</span><span class="p">,</span><span class="w"> </span><span class="n">proj_reslution_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">sor</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">online_points_filtered</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Online Pointcloud size: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">online_points</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">online_points_filtered</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">online_filtered_timer</span><span class="p">.</span><span class="n">End</span><span class="p">(</span><span class="s">&quot;online point calc end.&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">//  Obtain map pointcloud</span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">time</span><span class="o">::</span><span class="n">Timer</span><span class="w"> </span><span class="n">map_timer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">map_timer</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="w"> </span><span class="n">left_top_coord2d</span><span class="p">(</span><span class="n">lt_x</span><span class="p">,</span><span class="w"> </span><span class="n">lt_y</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ComposeMapCells</span><span class="p">(</span><span class="n">left_top_coord2d</span><span class="p">,</span><span class="w"> </span><span class="n">zone_id_</span><span class="p">,</span><span class="w"> </span><span class="n">resolution_id_</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">map_</span><span class="p">.</span><span class="n">GetConfig</span><span class="p">().</span><span class="n">map_resolutions_</span><span class="p">[</span><span class="n">resolution_id_</span><span class="p">],</span><span class="w"></span>
<span class="w">                  </span><span class="n">transform</span><span class="p">.</span><span class="n">inverse</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Convert map pointcloud to local corrdinate</span>
<span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">pcl_map_point_cloud</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cell_map_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Leaf</span><span class="o">&amp;</span><span class="w"> </span><span class="n">le</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_map_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">mean_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">le</span><span class="p">.</span><span class="n">mean_</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">mean_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">le</span><span class="p">.</span><span class="n">mean_</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">mean_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">le</span><span class="p">.</span><span class="n">mean_</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">pcl_map_point_cloud</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="p">(</span><span class="n">mean_0</span><span class="p">,</span><span class="w"> </span><span class="n">mean_1</span><span class="p">,</span><span class="w"> </span><span class="n">mean_2</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">map_timer</span><span class="p">.</span><span class="n">End</span><span class="p">(</span><span class="s">&quot;Map create end.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Set left top corner for reg</span>
<span class="w">  </span><span class="n">reg_</span><span class="p">.</span><span class="n">SetLeftTopCorner</span><span class="p">(</span><span class="n">map_left_top_corner_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Ndt calculation</span>
<span class="w">  </span><span class="n">reg_</span><span class="p">.</span><span class="n">SetInputTarget</span><span class="p">(</span><span class="n">cell_map_</span><span class="p">,</span><span class="w"> </span><span class="n">pcl_map_point_cloud</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">reg_</span><span class="p">.</span><span class="n">SetInputSource</span><span class="p">(</span><span class="n">online_points_filtered</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">time</span><span class="o">::</span><span class="n">Timer</span><span class="w"> </span><span class="n">ndt_timer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ndt_timer</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="w"> </span><span class="n">inv_R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transform</span><span class="p">.</span><span class="n">inverse</span><span class="p">().</span><span class="n">linear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4d</span><span class="w"> </span><span class="n">init_matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4d</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">init_matrix</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inv_R</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">output_cloud</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">reg_</span><span class="p">.</span><span class="n">Align</span><span class="p">(</span><span class="n">output_cloud</span><span class="p">,</span><span class="w"> </span><span class="n">init_matrix</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">ndt_timer</span><span class="p">.</span><span class="n">End</span><span class="p">(</span><span class="s">&quot;Ndt Align End.&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">fitness_score_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reg_</span><span class="p">.</span><span class="n">GetFitnessScore</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_converged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reg_</span><span class="p">.</span><span class="n">HasConverged</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reg_</span><span class="p">.</span><span class="n">GetFinalNumIteration</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4d</span><span class="w"> </span><span class="n">ndt_pose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reg_</span><span class="p">.</span><span class="n">GetFinalTransformation</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Ndt summary:&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Fitness Score: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fitness_score_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Has_converged: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">has_converged</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Iteration: %d: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Relative Ndt pose: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ndt_pose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ndt_pose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ndt_pose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Twv</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="w"> </span><span class="n">lidar_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">lidar_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transform</span><span class="p">.</span><span class="n">matrix</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">init_matrix</span><span class="p">.</span><span class="n">inverse</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ndt_pose</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Save results</span>
<span class="w">  </span><span class="n">location_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lidar_location</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">velodyne_extrinsic_</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">pre_input_location_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pose</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pre_estimate_location_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">location_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pre_imu_height_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">location_</span><span class="p">.</span><span class="n">translation</span><span class="p">()(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map_is_ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="ndt-voxel-grid-covariance">
<h3>ndt_voxel_grid_covariance<a class="headerlink" href="#ndt-voxel-grid-covariance" title="Permalink to this headline"></a></h3>
<p>叶子节点中点的个数，以及平局值和协方差。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Leaf</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Leaf</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">nr_points_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">mean_</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">Zero</span><span class="p">()),</span><span class="w"></span>
<span class="w">        </span><span class="n">icov_</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="o">::</span><span class="n">Zero</span><span class="p">())</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**@brief Get the number of points contained by this voxel. */</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">GetPointCount</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">nr_points_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**@brief Get the voxel centroid. */</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">GetMean</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">mean_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**@brief Get the inverse of the voxel covariance. */</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="w"> </span><span class="n">GetInverseCov</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">icov_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**@brief Number of points contained by voxel. */</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nr_points_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/**@brief 3D voxel centroid. */</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">mean_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/**@brief Inverse of voxel covariance matrix. */</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="w"> </span><span class="n">icov_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="voxelgridcovariance">
<h3>VoxelGridCovariance<a class="headerlink" href="#voxelgridcovariance" title="Permalink to this headline"></a></h3>
<p>Voxel的协方差计算，VoxelGridCovariance包含了一系列的叶子节点(Leaf)。</p>
<p>初始化voxel结构体，一是SetMap，二是构建kdtree_</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="cm">/**@brief Initializes voxel structure. */</span><span class="w"></span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cell_leaf</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="kt">bool</span><span class="w"> </span><span class="n">searchable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">voxel_centroids_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PointCloudPtr</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">PointCloud</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">SetMap</span><span class="p">(</span><span class="n">cell_leaf</span><span class="p">,</span><span class="w"> </span><span class="n">voxel_centroids_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">voxel_centroids_</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">kdtree_</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">voxel_centroids_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>把map_leaves中的值赋值给leaves_，并且把index保存到voxel_centroids_leaf_indices_中</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">VoxelGridCovariance</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">SetMap</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">map_leaves</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">PointCloudPtr</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">voxel_centroids_leaf_indices_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// input_输入点云不为空</span>

<span class="w">  </span><span class="c1">// Copy the header + allocate enough space for points</span>
<span class="w">  </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">is_dense</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 获取最大和最小的点云坐标</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span><span class="w"> </span><span class="n">min_p</span><span class="p">,</span><span class="w"> </span><span class="n">max_p</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">pcl</span><span class="o">::</span><span class="n">getMinMax3D</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">input_</span><span class="p">,</span><span class="w"> </span><span class="n">min_p</span><span class="p">,</span><span class="w"> </span><span class="n">max_p</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span><span class="w"> </span><span class="n">left_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span><span class="o">::</span><span class="n">Zero</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">left_top</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_left_top_corner_</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">min_p</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">left_top</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">max_p</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">left_top</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Compute the minimum and maximum bounding box values</span>
<span class="w">  </span><span class="n">min_b_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">min_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">max_b_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">max_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">min_b_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">min_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">max_b_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">max_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">min_b_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">min_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">max_b_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">max_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Compute the number of divisions needed along all axis</span>
<span class="w">  </span><span class="n">div_b_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_b_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min_b_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4i</span><span class="o">::</span><span class="n">Ones</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">div_b_</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Set up the division multiplier</span>
<span class="w">  </span><span class="n">divb_mul_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">div_b_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">div_b_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">div_b_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Clear the leaves</span>
<span class="w">  </span><span class="n">leaves_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">map_leaves</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">voxel_centroids_leaf_indices_</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">leaves_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">map_leaves</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Leaf</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell_leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_leaves</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">local_mean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_leaf</span><span class="p">.</span><span class="n">mean_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">map_left_top_corner_</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ijk0</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">local_mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min_b_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ijk1</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">local_mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min_b_</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ijk2</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">local_mean</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inverse_leaf_size_</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min_b_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Compute the centroid leaf index</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ijk0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">divb_mul_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ijk1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">divb_mul_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ijk2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">divb_mul_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">Leaf</span><span class="o">&amp;</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaves_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_leaf</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cell_leaf</span><span class="p">.</span><span class="n">nr_points_</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">min_points_per_voxel_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">PointT</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">leaf</span><span class="p">.</span><span class="n">mean_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">leaf</span><span class="p">.</span><span class="n">mean_</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">leaf</span><span class="p">.</span><span class="n">mean_</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">voxel_centroids_leaf_indices_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这里为什么可以根据index找到k_leaves？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointT</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">VoxelGridCovariance</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">RadiusSearch</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">PointT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LeafConstPtr</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">k_leaves</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">k_sqr_distances</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max_nn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">k_leaves</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Find neighbors within radius in the occupied voxel centroid cloud</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">k_indices</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">kdtree_</span><span class="p">.</span><span class="n">radiusSearch</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">k_indices</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">k_sqr_distances</span><span class="p">,</span><span class="w"> </span><span class="n">max_nn</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Find leaves corresponding to neighbors</span>
<span class="w">  </span><span class="n">k_leaves</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_indices</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">k_indices</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">iter</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">k_leaves</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaves_</span><span class="p">[</span><span class="n">voxel_centroids_leaf_indices_</span><span class="p">[</span><span class="o">*</span><span class="n">iter</span><span class="p">]]);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>通过Leaf的质心随机生成100个点进行点云的显示。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">VoxelGridCovariance</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">GetDisplayCloud</span><span class="p">(</span>
    <span class="n">pcl</span><span class="p">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="p">::</span><span class="n">PointXYZ</span><span class="o">&gt;*</span> <span class="n">cell_cloud</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="normaldistributionstransform">
<h3>NormalDistributionsTransform<a class="headerlink" href="#normaldistributionstransform" title="Permalink to this headline"></a></h3>
<p>设置目标点云</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetInputTarget</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cell_leaf</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">PointCloudTargetConstPtr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cloud</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cell_leaf</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AWARN</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Input leaf is empty.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cloud</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AWARN</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Input target is empty.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 设置目标点云，其中target_cells_为VoxelGridCovariance</span>
<span class="w">    </span><span class="n">target_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cloud</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">target_cells_</span><span class="p">.</span><span class="n">SetVoxelGridResolution</span><span class="p">(</span><span class="n">resolution_</span><span class="p">,</span><span class="w"> </span><span class="n">resolution_</span><span class="p">,</span><span class="w"> </span><span class="n">resolution_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">target_cells_</span><span class="p">.</span><span class="n">SetInputCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">target_cells_</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">cell_leaf</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>resolution_代表体素网格分辨率</p>
<p>step_size_牛顿线性查找最大步长</p>
<p>trans_probability_ 注册概率</p>
<p>nr_iterations_ 迭代次数</p>
<p>final_transformation_ 最后的转移矩阵</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PointSource</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">PointTarget</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">NormalDistributionsTransform</span><span class="o">&lt;</span><span class="n">PointSource</span><span class="p">,</span><span class="w"> </span><span class="n">PointTarget</span><span class="o">&gt;::</span><span class="w"></span>
<span class="w">    </span><span class="n">ComputeTransformation</span><span class="p">(</span><span class="n">PointCloudSourcePtr</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">guess</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">time</span><span class="o">::</span><span class="n">Timer</span><span class="w"> </span><span class="n">timer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">timer</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">nr_iterations_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">converged_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">gauss_c1</span><span class="p">,</span><span class="w"> </span><span class="n">gauss_c2</span><span class="p">,</span><span class="w"> </span><span class="n">gauss_d3</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Initializes the guassian fitting parameters (eq. 6.8) [Magnusson 2009]</span>
<span class="w">  </span><span class="n">gauss_c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">outlier_ratio_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">gauss_c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outlier_ratio_</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">resolution_</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">gauss_d3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">gauss_c2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">gauss_d1_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">gauss_c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gauss_c2</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">gauss_d3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">gauss_d2_</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="mi">-2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">log</span><span class="p">((</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">gauss_c1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="mf">-0.5</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gauss_c2</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">gauss_d3</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">gauss_d1_</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">guess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span><span class="o">::</span><span class="n">Identity</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Initialise final transformation to the guessed one</span>
<span class="w">    </span><span class="n">final_transformation_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">guess</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Apply guessed transformation prior to search for neighbours</span>
<span class="w">    </span><span class="n">transformPointCloud</span><span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">guess</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Initialize Point Gradient and Hessian</span>
<span class="w">  </span><span class="n">point_gradient_</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">point_gradient_</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">setIdentity</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">point_hessian_</span><span class="p">.</span><span class="n">setZero</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Transform</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">ColMajor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">eig_transformation</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">eig_transformation</span><span class="p">.</span><span class="n">matrix</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">final_transformation_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Convert initial guess matrix to 6 element transformation vector</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">delta_p</span><span class="p">,</span><span class="w"> </span><span class="n">score_gradient</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="w"> </span><span class="n">init_translation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eig_transformation</span><span class="p">.</span><span class="n">translation</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="w"> </span><span class="n">init_rotation</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">eig_transformation</span><span class="p">.</span><span class="n">rotation</span><span class="p">().</span><span class="n">eulerAngles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">init_translation</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">init_translation</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">init_translation</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">init_rotation</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">init_rotation</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">init_rotation</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hessian</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">delta_p_norm</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Calculate derivates of initial transform vector, subsequent derivative</span>
<span class="w">  </span><span class="c1">// calculations are done in the step length determination.</span>
<span class="w">  </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeDerivatives</span><span class="p">(</span><span class="o">&amp;</span><span class="n">score_gradient</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hessian</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">timer</span><span class="p">.</span><span class="n">End</span><span class="p">(</span><span class="s">&quot;Ndt ComputeDerivatives&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">time</span><span class="o">::</span><span class="n">Timer</span><span class="w"> </span><span class="n">loop_timer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">loop_timer</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">converged_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Store previous transformation</span>
<span class="w">    </span><span class="n">previous_transformation_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformation_</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Solve for decent direction using newton method, line 23 in Algorithm</span>
<span class="w">    </span><span class="c1">// 2 [Magnusson 2009]</span>
<span class="w">    </span><span class="n">Eigen</span><span class="o">::</span><span class="n">JacobiSVD</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">sv</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">hessian</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">ComputeFullU</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">ComputeFullV</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Negative for maximization as opposed to minimization</span>
<span class="w">    </span><span class="n">delta_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sv</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="o">-</span><span class="n">score_gradient</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate step length with guarnteed sufficient decrease [More,</span>
<span class="w">    </span><span class="c1">// Thuente 1994]</span>
<span class="w">    </span><span class="n">delta_p_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delta_p</span><span class="p">.</span><span class="n">norm</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">delta_p_norm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">delta_p_norm</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">delta_p_norm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">trans_probability_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">converged_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delta_p_norm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">delta_p_norm</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">delta_p</span><span class="p">.</span><span class="n">normalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">delta_p_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeStepLengthMt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">delta_p</span><span class="p">,</span><span class="w"> </span><span class="n">delta_p_norm</span><span class="p">,</span><span class="w"> </span><span class="n">step_size_</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">transformation_epsilon_</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">score</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="o">&amp;</span><span class="n">score_gradient</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hessian</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">delta_p</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">delta_p_norm</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">transformation_</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Translation</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">delta_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span><span class="w"></span>
<span class="w">                                      </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">delta_p</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w"></span>
<span class="w">                                      </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">delta_p</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">         </span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxis</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">delta_p</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">::</span><span class="n">UnitX</span><span class="p">())</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">         </span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxis</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">delta_p</span><span class="p">(</span><span class="mi">4</span><span class="p">)),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">::</span><span class="n">UnitY</span><span class="p">())</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">         </span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxis</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">delta_p</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">::</span><span class="n">UnitZ</span><span class="p">()))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">matrix</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delta_p</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nr_iterations_</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_iterations_</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">nr_iterations_</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">         </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">delta_p_norm</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">transformation_epsilon_</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">converged_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">nr_iterations_</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">loop_timer</span><span class="p">.</span><span class="n">End</span><span class="p">(</span><span class="s">&quot;Ndt loop.&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Store transformation probability.  The relative differences within each</span>
<span class="w">  </span><span class="c1">// scan registration are accurate but the normalization constants need to be</span>
<span class="w">  </span><span class="c1">// modified for it to be globally accurate</span>
<span class="w">  </span><span class="n">trans_probability_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>其中的公式推导需要接着分析<code class="docutils literal notranslate"><span class="pre">ndt_solver.hpp</span></code>。</p>
</div>
</div>
<div class="section" id="ndt-map">
<h2>ndt_map<a class="headerlink" href="#ndt-map" title="Permalink to this headline"></a></h2>
<p>ndt_map为ndt地图的主要说明目录，</p>
<div class="section" id="basemapnodepool">
<h3>BaseMapNodePool<a class="headerlink" href="#basemapnodepool" title="Permalink to this headline"></a></h3>
<p>BaseMapNodePool是一个map node对象池，其中is_fixed_size_表示大小固定，不会新增加大小。free_list_中存放还没有使用的节点，busy_nodes_中存放正在使用的节点，当需要释放的时候可以用ResetMapNode来进行资源的释放。</p>
<p>其中比较有意思的点在于，BaseMapNodePool在析构函数中进行资源释放，同时结合<code class="docutils literal notranslate"><span class="pre">ndt_map_node-&gt;SetIsChanged(true)</span></code>来保存node节点到硬盘，从而实现地图的制作过程。</p>
</div>
</div>
<div class="section" id="poses-interpolation-cc">
<h2>poses_interpolation.cc<a class="headerlink" href="#poses-interpolation-cc" title="Permalink to this headline"></a></h2>
<p>对pose进行插值，主要的处理在函数中</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">PosesInterpolation::DoInterpolation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 读取pose信息</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input_stds</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">velodyne</span><span class="o">::</span><span class="n">LoadPosesAndStds</span><span class="p">(</span><span class="n">input_poses_path_</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input_poses_</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input_stds</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="o">&amp;</span><span class="n">input_poses_timestamps_</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 读取pcd的index和时间戳</span>
<span class="w">  </span><span class="n">LoadPCDTimestamp</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Interpolation</span>
<span class="w">  </span><span class="n">PoseInterpolationByTime</span><span class="p">(</span><span class="n">input_poses_</span><span class="p">,</span><span class="w"> </span><span class="n">input_poses_timestamps_</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">ref_timestamps_</span><span class="p">,</span><span class="w"> </span><span class="n">ref_ids_</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out_indexes_</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="o">&amp;</span><span class="n">out_timestamps_</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out_poses_</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 保存pcd文件</span>
<span class="w">  </span><span class="n">WritePCDPoses</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>插值的主要逻辑在如下函数中，主要是根据lidar的时间戳，查找位姿，并且做插值，最后保存到文件。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">in_poses</span><span class="w">  </span><span class="c1">// 定位的pose列表</span>
<span class="n">in_timestamps</span><span class="w"> </span><span class="c1">// 定位的时间戳</span>
<span class="n">ref_timestamps</span><span class="w">  </span><span class="c1">// 点云的时间戳</span>
<span class="n">ref_indexes</span><span class="w">   </span><span class="c1">// 点云的index</span>
<span class="n">out_indexes</span><span class="w">  </span><span class="c1">// 输出的index</span>
<span class="n">out_timestamps</span><span class="w">  </span><span class="c1">// 输出的时间戳</span>
<span class="n">out_poses</span><span class="w">   </span><span class="c1">// 输出的姿态</span>

<span class="kt">void</span><span class="w"> </span><span class="n">PosesInterpolation</span><span class="o">::</span><span class="n">PoseInterpolationByTime</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_poses</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_timestamps</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ref_timestamps</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ref_indexes</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">out_indexes</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">out_timestamps</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">out_poses</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">out_indexes</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">out_timestamps</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">out_poses</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ref_timestamps</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">ref_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_timestamps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ref_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">in_timestamps</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">           </span><span class="n">in_timestamps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ref_timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="o">++</span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">in_timestamps</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">cur_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_timestamps</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">pre_timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_timestamps</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">cur_timestamp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pre_timestamp</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="n">cur_timestamp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ref_timestamp</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">cur_timestamp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pre_timestamp</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="w"> </span><span class="n">pre_pose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_poses</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3d</span><span class="w"> </span><span class="n">cur_pose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_poses</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="w"> </span><span class="nf">pre_quatd</span><span class="p">(</span><span class="n">pre_pose</span><span class="p">.</span><span class="n">linear</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Translation3d</span><span class="w"> </span><span class="nf">pre_transd</span><span class="p">(</span><span class="n">pre_pose</span><span class="p">.</span><span class="n">translation</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="w"> </span><span class="nf">cur_quatd</span><span class="p">(</span><span class="n">cur_pose</span><span class="p">.</span><span class="n">linear</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Translation3d</span><span class="w"> </span><span class="nf">cur_transd</span><span class="p">(</span><span class="n">cur_pose</span><span class="p">.</span><span class="n">translation</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Quaterniond</span><span class="w"> </span><span class="n">res_quatd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre_quatd</span><span class="p">.</span><span class="n">slerp</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">cur_quatd</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Translation3d</span><span class="w"> </span><span class="n">re_transd</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">re_transd</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre_transd</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cur_transd</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">re_transd</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre_transd</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cur_transd</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">re_transd</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre_transd</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cur_transd</span><span class="p">.</span><span class="n">z</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">out_poses</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">re_transd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">res_quatd</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">out_indexes</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">ref_index</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">out_timestamps</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">ref_timestamp</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AWARN</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;[WARN] No more poses. Exit now.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Frame_id: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, daohu527.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>