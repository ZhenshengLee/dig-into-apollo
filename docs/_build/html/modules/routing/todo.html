<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SearchRoute &mdash; dig-into-apollo  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> dig-into-apollo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../what_is_apollo/readme.html">Dig into Apollo - Introduction </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cyber/readme.html">Dig into Apollo - Cyber </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docker/readme.html">Dig into Apollo - Docker </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../library/readme.html">Dig into Apollo - Library </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../papers/readme.html">Dig into Apollo - Papers </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance/readme.html">Dig into Apollo - Performance </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../questions/readme.html">Dig into Apollo - Questions </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../simulation/readme.html">Dig into Apollo - Simulation </a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to_build/readme.html">Dig into Apollo - Build </a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dig-into-apollo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>SearchRoute</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modules/routing/todo.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <ol class="arabic simple">
<li><p>为什么会出现找不到节点的情况？？？
节点没有连接，所以需要找到节点附近最近的路段。</p></li>
<li><p>Astar算法
http://www-cs-students.stanford.edu/~amitp/gameprog.html#Paths</p></li>
</ol>
<p>http://theory.stanford.edu/~amitp/GameProgramming/</p>
<p>https://www.geeksforgeeks.org/a-search-algorithm/</p>
<p>http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html</p>
<ol class="arabic simple" start="3">
<li><p>“RoutingComponent”类继承至”cyber::Component”，并且申明为”public”方式，”cyber::Component”是一个模板类，它定义了”Initialize”和”Process”方法。</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">M0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span> <span class="n">NullType</span><span class="p">,</span> <span class="n">NullType</span><span class="p">,</span> <span class="n">NullType</span><span class="o">&gt;</span> <span class="p">:</span> <span class="n">public</span> <span class="n">ComponentBase</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
  <span class="n">Component</span><span class="p">()</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">Component</span><span class="p">()</span> <span class="n">override</span> <span class="p">{}</span>
  <span class="nb">bool</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">const</span> <span class="n">ComponentConfig</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">Process</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span> <span class="n">msg</span><span class="p">);</span>

 <span class="n">private</span><span class="p">:</span>
  <span class="n">virtual</span> <span class="nb">bool</span> <span class="n">Proc</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>// todo 模板方法中为虚函数，而继承类中为公有方法？为什么？</p>
<div class="section" id="searchroute">
<h1>SearchRoute<a class="headerlink" href="#searchroute" title="Permalink to this headline"></a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool Navigator::SearchRoute(const RoutingRequest&amp; request,
                            RoutingResponse* const response) {
  ...
  // 初始化规划点和起点
  std::vector&lt;const TopoNode*&gt; way_nodes;
  std::vector&lt;double&gt; way_s;
  if (!Init(request, graph_.get(), &amp;way_nodes, &amp;way_s)) {
    return false;
  }
  // 根据节点和起点，查找返回结果，注意这里返回的是一段范围
  std::vector&lt;NodeWithRange&gt; result_nodes;
  if (!SearchRouteByStrategy(graph_.get(), way_nodes, way_s, &amp;result_nodes)) {
    return false;
  }
  if (result_nodes.empty()) {
    return false;
  }
  // 插入起点和终点
  result_nodes.front().SetStartS(request.waypoint().begin()-&gt;s());
  result_nodes.back().SetEndS(request.waypoint().rbegin()-&gt;s());
  // 生成通道区域
  if (!result_generator_-&gt;GeneratePassageRegion(
          graph_-&gt;MapVersion(), request, result_nodes, topo_range_manager_,
          response)) {
    return false;
  }
  ...
}
</pre></div>
</div>
</div>
<div class="section" id="filllaneinfoifmissing">
<h1>FillLaneInfoIfMissing<a class="headerlink" href="#filllaneinfoifmissing" title="Permalink to this headline"></a></h1>
<p>如果routing请求中没有包含lane信息，则会自动补全这一部分信息。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>RoutingRequest Routing::FillLaneInfoIfMissing(
    const RoutingRequest&amp; routing_request) {
  RoutingRequest fixed_request(routing_request);
  // 遍历routing请求的点
  for (int i = 0; i &lt; routing_request.waypoint_size(); ++i) {
    const auto&amp; lane_waypoint = routing_request.waypoint(i);
    // routing_request请求的点有lane_id，则表示在路上，不用查找
    if (lane_waypoint.has_id()) {
      continue;
    }
    auto point = common::util::MakePointENU(lane_waypoint.pose().x(),
                                            lane_waypoint.pose().y(),
                                            lane_waypoint.pose().z());

    double s = 0.0;
    double l = 0.0;
    hdmap::LaneInfoConstPtr lane;
    // FIXME(all): select one reasonable lane candidate for point=&gt;lane
    // is one to many relationship.
    // 找到当前点最近的lane信息
    if (hdmap_-&gt;GetNearestLane(point, &amp;lane, &amp;s, &amp;l) != 0) {
      AERROR &lt;&lt; &quot;Failed to find nearest lane from map at position: &quot;
             &lt;&lt; point.DebugString();
      return routing_request;
    }
    auto waypoint_info = fixed_request.mutable_waypoint(i);
    waypoint_info-&gt;set_id(lane-&gt;id().id());
    waypoint_info-&gt;set_s(s);
  }
  return fixed_request;
}
</pre></div>
</div>
<p>BlackListRangeGenerator生成黑名单路段
通过RoutingRequest中的black_lane和black_road来生成黑名单路段，这里会设置一整段路都为黑名单。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">BlackListRangeGenerator</span><span class="p">::</span><span class="n">GenerateBlackMapFromRequest</span><span class="p">(</span>
    <span class="n">const</span> <span class="n">RoutingRequest</span><span class="o">&amp;</span> <span class="n">request</span><span class="p">,</span> <span class="n">const</span> <span class="n">TopoGraph</span><span class="o">*</span> <span class="n">graph</span><span class="p">,</span>
    <span class="n">TopoRangeManager</span><span class="o">*</span> <span class="n">const</span> <span class="n">range_manager</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">AddBlackMapFromLane</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">range_manager</span><span class="p">);</span>
  <span class="n">AddBlackMapFromRoad</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">range_manager</span><span class="p">);</span>
  <span class="n">range_manager</span><span class="o">-&gt;</span><span class="n">SortAndMerge</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通过Terminal来设置黑名单，应用场景是设置routing的起点和终点。这里的起点和终点都是一个点，功能是把lane切分为2个subNode</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">BlackListRangeGenerator</span><span class="p">::</span><span class="n">AddBlackMapFromTerminal</span><span class="p">(</span>
    <span class="n">const</span> <span class="n">TopoNode</span><span class="o">*</span> <span class="n">src_node</span><span class="p">,</span> <span class="n">const</span> <span class="n">TopoNode</span><span class="o">*</span> <span class="n">dest_node</span><span class="p">,</span> <span class="n">double</span> <span class="n">start_s</span><span class="p">,</span>
    <span class="n">double</span> <span class="n">end_s</span><span class="p">,</span> <span class="n">TopoRangeManager</span><span class="o">*</span> <span class="n">const</span> <span class="n">range_manager</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">double</span> <span class="n">start_length</span> <span class="o">=</span> <span class="n">src_node</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">();</span>
  <span class="n">double</span> <span class="n">end_length</span> <span class="o">=</span> <span class="n">dest_node</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start_s</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">||</span> <span class="n">start_s</span> <span class="o">&gt;</span> <span class="n">start_length</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AERROR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Illegal start_s: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">start_s</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;, length: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">start_length</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">end_s</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">||</span> <span class="n">end_s</span> <span class="o">&gt;</span> <span class="n">end_length</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AERROR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Illegal end_s: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">end_s</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;, length: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">end_length</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">double</span> <span class="n">start_cut_s</span> <span class="o">=</span> <span class="n">MoveSBackward</span><span class="p">(</span><span class="n">start_s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">range_manager</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">src_node</span><span class="p">,</span> <span class="n">start_cut_s</span><span class="p">,</span> <span class="n">start_cut_s</span><span class="p">);</span>
  <span class="n">AddBlackMapFromOutParallel</span><span class="p">(</span><span class="n">src_node</span><span class="p">,</span> <span class="n">start_cut_s</span> <span class="o">/</span> <span class="n">start_length</span><span class="p">,</span>
                             <span class="n">range_manager</span><span class="p">);</span>

  <span class="n">double</span> <span class="n">end_cut_s</span> <span class="o">=</span> <span class="n">MoveSForward</span><span class="p">(</span><span class="n">end_s</span><span class="p">,</span> <span class="n">end_length</span><span class="p">);</span>
  <span class="n">range_manager</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">dest_node</span><span class="p">,</span> <span class="n">end_cut_s</span><span class="p">,</span> <span class="n">end_cut_s</span><span class="p">);</span>
  <span class="n">AddBlackMapFromInParallel</span><span class="p">(</span><span class="n">dest_node</span><span class="p">,</span> <span class="n">end_cut_s</span> <span class="o">/</span> <span class="n">end_length</span><span class="p">,</span> <span class="n">range_manager</span><span class="p">);</span>
  <span class="n">range_manager</span><span class="o">-&gt;</span><span class="n">SortAndMerge</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>TODO: 如果在dreamview里设置多个routing点的情况，那么会出现第一段的终点和第二段的起点有overlap的情况，排序之后，会出现2厘米的gap?目前看起来不会影响，因为会往前开，另外为什么要设置往后偏移1厘米，如果刚好停在边界点上，会如何处理？？？</p>
</div></blockquote>
<p>TODO: 判断是否足够进行切换Lane,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool TopoNode::IsOutRangeEnough(const std::vector&lt;NodeSRange&gt;&amp; range_vec,
                                double start_s, double end_s) {
  // 是否足够切换Lane
  if (!NodeSRange::IsEnoughForChangeLane(start_s, end_s)) {
    return false;
  }
  int start_index = BinarySearchForSLarger(range_vec, start_s);
  int end_index = BinarySearchForSSmaller(range_vec, end_s);

  int index_diff = end_index - start_index;
  if (start_index &lt; 0 || end_index &lt; 0) {
    return false;
  }
  if (index_diff &gt; 1) {
    return true;
  }

  double pre_s_s = std::max(start_s, range_vec[start_index].StartS());
  double suc_e_s = std::min(end_s, range_vec[end_index].EndS());

  if (index_diff == 1) {
    double dlt = range_vec[start_index].EndS() - pre_s_s;
    dlt += suc_e_s - range_vec[end_index].StartS();
    return NodeSRange::IsEnoughForChangeLane(dlt);
  }
  if (index_diff == 0) {
    return NodeSRange::IsEnoughForChangeLane(pre_s_s, suc_e_s);
  }
  return false;
}
</pre></div>
</div>
</div>
<div class="section" id="generatepassageregion">
<h1>GeneratePassageRegion<a class="headerlink" href="#generatepassageregion" title="Permalink to this headline"></a></h1>
<p>生成passageRegion，这里需要注意每个Passage中的直行都是合并了的，也就是说passage中只有每次换向的时候才会从新启用新的passage。</p>
</div>
<div class="section" id="subtopograph">
<h1>SubTopoGraph<a class="headerlink" href="#subtopograph" title="Permalink to this headline"></a></h1>
<p>构建subtopograph的作用就是为了方便routing切割lane，然后把lane分割成几个子节点，子节点的网络是如何建立的？如何根据这些节点来进行查找和计算代价？？？</p>
</div>
<div class="section" id="navigator-mergeroute">
<h1>Navigator::MergeRoute<a class="headerlink" href="#navigator-mergeroute" title="Permalink to this headline"></a></h1>
<p>没有看出来从哪里mergeRoute</p>
</div>
<div class="section" id="astarstrategy-search">
<h1>AStarStrategy::Search<a class="headerlink" href="#astarstrategy-search" title="Permalink to this headline"></a></h1>
<p>具体的查找过程，每次还是会从子网络查找</p>
</div>
<div class="section" id="id1">
<h1><a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1>
</div>
<div class="section" id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline"></a></h1>
<p>城市道路分析：
https://geoffboeing.com/2016/11/osmnx-python-street-networks/
https://automating-gis-processes.github.io/2018/notebooks/L6/network-analysis.html
https://socialhub.technion.ac.il/wp-content/uploads/2017/08/revise_version-final.pdf
https://stackoverflow.com/questions/29639968/shortest-path-using-openstreetmap-datanodes-and-ways</p>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, daohu527.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>