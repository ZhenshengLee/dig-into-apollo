<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dig into Apollo - Cyber &mdash; dig-into-apollo  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> dig-into-apollo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">快速开始:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../what_is_apollo/readme.html">1. 什么是Apollo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to_build/readme.html">2. 如何编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docker/readme.html">3. 启动容器</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../readme.html">1. Cyber</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/audio/readme.html">2. Audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/bridge/readme.html">3. Bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/canbus/readme.html">4. Canbus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/control/readme.html">5. Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/data/readme.html">6. Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/dreamview/readme.html">7. Dreamview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/drivers/readme.html">8. Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/guardian/readme.html">9. Guardian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/localization/readme.html">10. Localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/map/readme.html">11. Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/monitor/readme.html">12. Monitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/perception/readme.html">13. Perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/planning/readme.html">14. Planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/prediction/readme.html">15. Prediction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/routing/readme.html">16. Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/routing/readme.html#id5">17. Routing模块分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/tools/readme.html">18. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/transform/readme.html">19. Transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/v2x/readme.html">20. V2X</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../performance/readme.html">21. 性能分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../simulation/readme.html">22. 仿真</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">参考</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../library/readme.html">1. 引用的库</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../papers/readme.html">2. 论文</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../questions/readme.html">3. 常见问题</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dig-into-apollo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Dig into Apollo - Cyber </li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/cyber/source/readme.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="dig-into-apollo-cyber-github">
<h1>Dig into Apollo - Cyber <img alt="GitHub" src="https://img.shields.io/github/license/daohu527/Dig-into-Apollo.svg?style=popout" /><a class="headerlink" href="#dig-into-apollo-cyber-github" title="Permalink to this headline"></a></h1>
<p>写在之前，之前的分析都是一些源码级别的分析，发现一开始就深入源码，很容易陷进去，特别是模块非常多的情况，需要看很多遍才能理解清楚。要写出更容易理解的文档，需要的不是事无巨细的分析代码，更主要的是能够把复杂的东西抽象出来，变为简单的东西。一个很简答的例子是画函数调用流程图很简单，但是要把流程图转换成框图却很难。</p>
<div class="section" id="id1">
<h2>数据处理流程<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2>
<p>我们先看下cyber中整个的数据处理流程，通过理解数据流程中各个模块如何工作，来搞清楚每个模块的作用，然后我们再接着分析具体的模块。<br />
<img alt="cyber数据流程" src="../../_images/data_progress.jpg" /></p>
<p>如上图所示，cyber的数据流程可以分为6个过程。</p>
<ol class="arabic simple">
<li><p>Node节点中的Writer往通道里面写数据。</p></li>
<li><p>通道中的Transmitter发布消息，通道中的Receiver订阅消息。</p></li>
<li><p>Receiver接收到消息之后，触发回调，触发DataDispather进行消息分发。</p></li>
<li><p>DataDispather接收到消息后，把消息放入CacheBuffer，并且触发Notifier，通知对应的DataVisitor处理消息。</p></li>
<li><p>DataVisitor把数据从CacheBuffer中读出，并且进行融合，然后通过notifier_唤醒对应的协程。</p></li>
<li><p>协程执行对应的注册回调函数，进行数据处理，处理完成之后接着进入睡眠状态。</p></li>
</ol>
<p>对数据流程有整体的认识之后，下面我们在分析具体的每个模块，我们还是按照功能划分。</p>
</div>
<div class="section" id="id2">
<h2>整体介绍<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2>
<p>首先我们对cyber中各个模块做一个简单的介绍，之后再接着分析。实际上我们只要搞清楚了下面一些概念之间的关系，就基本上理解清楚了整个Cyber的数据流程。</p>
<div class="section" id="componentnode">
<h3>1.Component和Node的关系<a class="headerlink" href="#componentnode" title="Permalink to this headline"></a></h3>
<p>Component是cyber中封装好的数据处理流程，对用户来说，对应自动驾驶中的Planning Component, Perception Component等，目的是帮助我们更方便的订阅和处理消息。实际上Component模块在加载之后会执行”Initialize()”函数，这是个隐藏的初始化过程，对用户不可见。在”Initialize”中，Component会创建一个Node节点，概念上对应ROS的节点，<strong>每个Component模块只能有一个Node节点</strong>，也就是说每个Component模块有且只能有一个节点，在Node节点中进行消息订阅和发布。</p>
</div>
<div class="section" id="nodereader-writer">
<h3>2.Node和Reader\Writer的关系<a class="headerlink" href="#nodereader-writer" title="Permalink to this headline"></a></h3>
<p>在Node节点中可以创建Reader订阅消息，也可以创建Writer发布消息，每个Node节点中可以创建多个Reader和Writer。</p>
</div>
<div class="section" id="readerreceiver-writertransmitter-channel">
<h3>3.Reader和Receiver,Writer和Transmitter,Channel的关系<a class="headerlink" href="#readerreceiver-writertransmitter-channel" title="Permalink to this headline"></a></h3>
<p>一个Channel对应一个Topic，概念上对应ROS的消息通道，每个Topic都是唯一的。而Channel中包括一个发送器(Transmitter)和接收器(Receiver)，通过Receiver接收消息，通过Transmitter发送消息。<br />
一个Reader只能订阅一个通道的消息，如果一个Node需要订阅多个通道的消息，需要创建多个Reader。同理一个Writer也只能发布一个通道的消息，如果需要发布多个消息，需要创建多个Writer。Reader中调用Receiver订阅消息，而Writer通过Transmitter发布消息。</p>
</div>
<div class="section" id="receiver-datadispatcherdatavisitor">
<h3>4.Receiver, DataDispatcher和DataVisitor的关系<a class="headerlink" href="#receiver-datadispatcherdatavisitor" title="Permalink to this headline"></a></h3>
<p>每一个Receiver接收到消息之后，都会触发回调，回调中触发DataDispather（消息分发器）发布消息，DataDispather是一个单例，所有的数据分发都在数据分发器中进行，DataDispather会把数据放到对应的缓存中，然后Notify(通知)对应的协程（实际上这里调用的是DataVisitor中注册的Notify）去处理消息。<br />
DataVisitor（消息访问器）是一个辅助的类，<strong>一个数据处理过程对应一个DataVisitor，通过在DataVisitor中注册Notify（唤醒对应的协程，协程执行绑定的回调函数），并且注册对应的Buffer到DataDispather</strong>，这样在DataDispather的时候会通知对应的DataVisitor去唤醒对应的协程。<br />
也就是说DataDispather（消息分发器）发布对应的消息到DataVisitor，DataVisitor（消息访问器）唤醒对应的协程，协程中执行绑定的数据处理回调函数。</p>
</div>
<div class="section" id="datavisitorcroutine">
<h3>5.DataVisitor和Croutine的关系<a class="headerlink" href="#datavisitorcroutine" title="Permalink to this headline"></a></h3>
<p>实际上DataVisitor中的Notify是通过唤醒协程（为了方便理解也可以理解为线程，可以理解为你有一个线程池，通过线程池绑定数据处理函数，数据到来之后就唤醒对应的线程去执行任务），每个协程绑定了一个数据处理函数和一个DataVisitor，数据到达之后，通过DataVisitor中的Notify唤醒对应的协程，执行数据处理回调，执行完成之后协程进入休眠状态。</p>
</div>
<div class="section" id="scheduler-taskcroutine">
<h3>6.Scheduler, Task和Croutine<a class="headerlink" href="#scheduler-taskcroutine" title="Permalink to this headline"></a></h3>
<p>通过上述分析，<strong>数据处理的过程实际上就是通过协程完成的，每一个协程被称为一个Task，所有的Task(任务)都由Scheduler进行调度</strong>。从这里我们可以分析得出实际上Cyber的实时调度由协程去保障，并且可以灵活的通过协程去设置对应的调度策略，当然协程依赖于进程，Apollo在linux中设置进程的优先级为实时轮转，先保障进程的优先级最高，然后内部再通过协程实现对应的调度策略。<br />
协程和线程的优缺点这里就不展开了，这里有一个疑问是协程不能被终止，除非协程主动退出，这里先留一个伏笔，后面我们再分析协程的调度问题。</p>
<p>上述就是各个概念之间的关系，上述介绍对理解数据的流程非常有帮助，希望有时间的时候，大家可以画一下对应的数据流程图和关系。</p>
</div>
</div>
<div class="section" id="component">
<h2>Component介绍<a class="headerlink" href="#component" title="Permalink to this headline"></a></h2>
<p>我们首先需要清楚一点，component实际上是cyber为了帮助我们特意实现的对象，component加载的时候会自动帮我们创建一个node，通过node来订阅和发布对应的消息，每个component有且只能对应一个node。<br />
component对用户提供2个接口”Init()”和”Proc()”，用户在Init中进行初始化，在”Proc”中接收Topic执行具体的算法。对用户隐藏的部分包括component的”Initialize()”初始化，以及”Process()”调用执行。<br />
component还可以动态的加载和卸载，这也可以对应到在dreamviewer上动态的打开关系模块。下面我们先大致介绍下component的工作流程，然后再具体介绍各个模块。</p>
<div class="section" id="id3">
<h3>component工作流程<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h3>
<p>component的工作流程大致如下：</p>
<ol class="arabic simple">
<li><p>通过继承”cyber::Component”，用户自定义一个模块，并且实现”Init()”和”Proc()”函数。编译生成”.so”文件。</p></li>
<li><p>通过classloader加载component模块到内存，创建component对象，调用”Initialize()”初始化。（Initialize中会调用Init）</p></li>
<li><p>创建协程任务，并且注册”Process()”回调，当数据到来的时候，唤醒对象的协程任务执行”Process()”处理数据。（Process会调用Proc）
综上所述，component帮助用户把初始化和数据收发的流程进行了封装，减少了用户的工作量，component封装了整个数据的收发流程，component本身并不是单独的一个线程执行，模块的初始化都在主线程中执行，而具体的任务则是在协程池中执行。</p></li>
</ol>
</div>
<div class="section" id="cyber">
<h3>cyber入口<a class="headerlink" href="#cyber" title="Permalink to this headline"></a></h3>
<p>cyber的入口在”cyber/mainboard/mainboard.cc”中，主函数中先进行cyber的初始化，然后启动cyber模块，然后运行，一直等到系统结束。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 解析参数</span>
<span class="w">  </span><span class="n">ModuleArgument</span><span class="w"> </span><span class="n">module_args</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">module_args</span><span class="p">.</span><span class="n">ParseArgument</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. 初始化cyber</span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">Init</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 3. 启动cyber模块</span>
<span class="w">  </span><span class="n">ModuleController</span><span class="w"> </span><span class="n">controller</span><span class="p">(</span><span class="n">module_args</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">controller</span><span class="p">.</span><span class="n">Init</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">controller</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;module start error.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 4. 等待直到程序退出</span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">WaitForShutdown</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">controller</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h2>Cyber实现的功能<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2>
<p>cyber提供的功能概括起来包括2方面：</p>
<ol class="arabic simple">
<li><p><strong>消息队列</strong> - 主要作用是接收和发送各个节点的消息，涉及到消息的发布、订阅以及消息的buffer缓存等。</p></li>
<li><p><strong>实时调度</strong> - 主要作用是调度处理上述消息的算法模块，保证算法模块能够实时调度处理消息。</p></li>
</ol>
<p>除了这2方面的工作，cyber还需要提供以下2部分的工作：</p>
<ol class="arabic simple">
<li><p><strong>用户接口</strong> - 提供灵活的用户接口</p></li>
<li><p><strong>工具</strong> - 提供一系列的工具，例如bag包播放，点云可视化，消息监控等</p></li>
</ol>
<p><img alt="cyber" src="cyber/source/img/arch.jpg" /><br />
总结起来就是，cyber是一个分布式收发消息，和调度框架，同时对外提供一系列的工具和接口来辅助开发和定位问题。其中cyber对比ROS来说有很多优势，唯一的劣势是cyber相对ROS没有丰富的算法库支持。</p>
<p>下面我们开始分析整个cyber的代码流程。</p>
</div>
<div class="section" id="id5">
<h2>cyber入口<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2>
<p>cyber的入口在”cyber/mainboard”目录中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── mainboard.cc           // 主函数
├── module_argument.cc     // 模块输入参数
├── module_argument.h
├── module_controller.cc   // 模块加载，卸载
└── module_controller.h
</pre></div>
</div>
<p>mainboard中的文件比较少，也很好理解，我们先从”mainboard.cc”中开始分析：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">google</span><span class="o">::</span><span class="n">SetUsageMessage</span><span class="p">(</span><span class="s">&quot;we use this program to load dag and run user apps.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 注册信号量，当出现系统错误时，打印堆栈信息</span>
<span class="w">  </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span><span class="w"> </span><span class="n">SigProc</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGABRT</span><span class="p">,</span><span class="w"> </span><span class="n">SigProc</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// parse the argument</span>
<span class="w">  </span><span class="c1">// 解析参数</span>
<span class="w">  </span><span class="n">ModuleArgument</span><span class="w"> </span><span class="n">module_args</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">module_args</span><span class="p">.</span><span class="n">ParseArgument</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// initialize cyber</span>
<span class="w">  </span><span class="c1">// 初始化cyber</span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">Init</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// start module</span>
<span class="w">  </span><span class="c1">// 加载模块</span>
<span class="w">  </span><span class="n">ModuleController</span><span class="w"> </span><span class="n">controller</span><span class="p">(</span><span class="n">module_args</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">controller</span><span class="p">.</span><span class="n">Init</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">controller</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;module start error.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 等待cyber关闭</span>
<span class="w">  </span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">WaitForShutdown</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 卸载模块</span>
<span class="w">  </span><span class="n">controller</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;exit mainboard.&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述是”mainboard.cc”的主函数，下面我们重点介绍下具体的过程。</p>
<div class="section" id="id6">
<h3>打印堆栈<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h3>
<p>在主函数中注册了信号量”SIGSEGV”和”SIGABRT”，当系统出现错误的时候（空指针，异常）等，这时候就会触发打印堆栈信息，也就是说系统报错的时候打印出错的堆栈，方便定位问题，<a class="reference external" href="https://www.runoob.com/cplusplus/cpp-signal-handling.html">参考</a>。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// 注册信号量，当出现系统错误时，打印堆栈信息</span>
<span class="w">  </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span><span class="w"> </span><span class="n">SigProc</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGABRT</span><span class="p">,</span><span class="w"> </span><span class="n">SigProc</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>打印堆栈的函数在”SigProc”中实现，而打印堆栈的实现是通过”backtrace”实现，<a class="reference external" href="https://www.gnu.org/software/libc/manual/html_node/Backtraces.html">参考</a>。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 打印堆栈信息</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ShowStack</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">[</span><span class="n">STACK_BUF_LEN</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">backtrace</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">STACK_BUF_LEN</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">symbols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">backtrace_symbols</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=============call stack begin:================&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=============call stack end:================&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>解析参数<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h3>
<p>解析参数是在”ModuleArgument”类中实现的，主要是解析加载DAG文件时候带的参数。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ModuleArgument::ParseArgument</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 二进制模块名称</span>
<span class="w">  </span><span class="n">binary_name_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">basename</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 解析参数</span>
<span class="w">  </span><span class="n">GetOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 如果没有process_group_和sched_name_，则赋值为默认值</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">process_group_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">process_group_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_process_group_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sched_name_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sched_name_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_sched_name_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 如果有，则设置对应的参数</span>
<span class="w">  </span><span class="n">GlobalData</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetProcessGroup</span><span class="p">(</span><span class="n">process_group_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">GlobalData</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetSchedName</span><span class="p">(</span><span class="n">sched_name_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;binary_name_ is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">binary_name_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, process_group_ is &quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">process_group_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, has &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dag_conf_list_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; dag conf&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 打印dag_conf配置，这里的dag是否可以设置多个？？？</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dag</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">dag_conf_list_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;dag_conf: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">dag</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>模块加载<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h3>
<p>在”ModuleController”实现cyber模块的加载，在”ModuleController::Init()”中调用”LoadAll()”来加载所有模块，我们接着看cyber是如何加载模块。</p>
<ol class="arabic simple">
<li><p>首先是找到模块的路径</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">module_config</span><span class="p">.</span><span class="n">module_library</span><span class="p">().</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">load_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">module_config</span><span class="p">.</span><span class="n">module_library</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">load_path</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">common</span><span class="o">::</span><span class="n">GetAbsolutePath</span><span class="p">(</span><span class="n">work_root</span><span class="p">,</span><span class="w"> </span><span class="n">module_config</span><span class="p">.</span><span class="n">module_library</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>通过”class_loader_manager_”加载模块，后面我们会接着分析”ClassLoaderManager”的具体实现，加载好对应的类之后在创建对应的对象，并且初始化对象（调用对象的Initialize()方法，也就是说所有的cyber模块都是通过Initialize()方法启动的，后面我们会接着分析Initialize具体干了什么）。<br />
这里的”classloader”其实类似java中的classloader，即java虚拟机在运行时加载对应的类，并且实例化对象。<br />
cyber中其实也是实现了类型通过动态加载并且实例化类的功能，好处是可以动态加载和关闭单个cyber模块(定位，感知，规划等)，也就是在dreamview中的模块开关按钮，实际上就是动态的加载和卸载对应的模块。</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// 通过类加载器加载load_path下的模块</span>
<span class="w">    </span><span class="n">class_loader_manager_</span><span class="p">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="n">load_path</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 加载模块</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">module_config</span><span class="p">.</span><span class="n">components</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">class_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">component</span><span class="p">.</span><span class="n">class_name</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 创建对象</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">class_loader_manager_</span><span class="p">.</span><span class="n">CreateClassObj</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="p">(</span><span class="n">class_name</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 调用对象的Initialize方法</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">Initialize</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="n">config</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">component_list_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">base</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 加载定时器模块</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">module_config</span><span class="p">.</span><span class="n">timer_components</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">class_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">component</span><span class="p">.</span><span class="n">class_name</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">class_loader_manager_</span><span class="p">.</span><span class="n">CreateClassObj</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="p">(</span><span class="n">class_name</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">Initialize</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="n">config</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">component_list_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">base</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述就是cyber mainboard的整个流程，cyber main函数中先解析dag参数，然后根据解析的参数，通过类加载器动态的加载对应的模块，然后调用Initialize方法初始化模块。</p>
<p>下面我们会接着分析类加载器(ClassLoaderManager)</p>
</div>
</div>
<div class="section" id="class-loader">
<h2>类加载器(class_loader)<a class="headerlink" href="#class-loader" title="Permalink to this headline"></a></h2>
<p>类加载器的作用就是动态的加载动态库，然后实例化对象。我们先来解释下，首先apollo中的各个module都会编译为一个动态库，拿planning模块来举例子，在”planning/dag/planning.dag”中，会加载：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module_config</span> <span class="p">{</span>
  <span class="n">module_library</span> <span class="p">:</span> <span class="s2">&quot;/apollo/bazel-bin/modules/planning/libplanning_component.so&quot;</span>
</pre></div>
</div>
<p>也就是说，apollo中的模块都会通过类加载器以动态库的方式加载，然后实例化，之后再调用Initialize方法初始化。也就是说，我们讲清楚下面3个问题，也就是讲清楚了类加载器的原理。</p>
<ol class="arabic simple">
<li><p>cyber如何加载apollo模块？</p></li>
<li><p>如何实例化模块?</p></li>
<li><p>如何初始化模块?</p></li>
</ol>
<div class="section" id="id9">
<h3>目录结构<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h3>
<p>类加载器的实现在”cyber/class_loader”目录中，通过”Poco/SharedLibrary.h”库来实现动态库的加载，关于Poco动态库的加载可以<a class="reference external" href="https://pocoproject.org/docs/Poco.SharedLibrary.html">参考</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>├── BUILD                  // 编译文件
├── class_loader.cc        // 类加载器
├── class_loader.h
├── class_loader_manager.cc  // 类加载器管理
├── class_loader_manager.h
├── class_loader_register_macro.h  // 类加载器注册宏定义
└── utility
    ├── class_factory.cc           // 类工厂
    ├── class_factory.h
    ├── class_loader_utility.cc    // 类加载器工具类
    └── class_loader_utility.h
</pre></div>
</div>
</div>
<div class="section" id="classloader">
<h3>类加载器(ClassLoader)<a class="headerlink" href="#classloader" title="Permalink to this headline"></a></h3>
<p>我们先从”class_loader.h”开始看起，首先我们分析下”class_loader”实现的具体方法：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ClassLoader</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">ClassLoader</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">library_path</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">ClassLoader</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 库是否已经加载</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsLibraryLoaded</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 加载库</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">LoadLibrary</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 卸载库</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">UnloadLibrary</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 获取库的路径</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">GetLibraryPath</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 获取累名称</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Base</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetValidClassNames</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 实例化类对象</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Base</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CreateClassObj</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">class_name</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类是否有效</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Base</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsClassValid</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">class_name</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 当类删除</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Base</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">OnClassObjDeleter</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类的路径</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">library_path_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类加载引用次数</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">loadlib_ref_count_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类加载引用次数锁</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">loadlib_ref_count_mutex_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类引用次数</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">classobj_ref_count_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类引用次数锁</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">classobj_ref_count_mutex_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>可以看到类加载器主要是提供了加载类，卸载类和实例化类的接口。实际上加载类和卸载类的实现都比较简单，都是调用”utility”类中的实现，我们暂时先放一边，先看下实例化对象的实现。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>template &lt;typename Base&gt;
std::shared_ptr&lt;Base&gt; ClassLoader::CreateClassObj(
    const std::string&amp; class_name) {
  // 加载库
  if (!IsLibraryLoaded()) {
    LoadLibrary();
  }

  // 根据类名称创建对象
  Base* class_object = utility::CreateClassObj&lt;Base&gt;(class_name, this);

  // 类引用计数加1
  std::lock_guard&lt;std::mutex&gt; lck(classobj_ref_count_mutex_);
  classobj_ref_count_ = classobj_ref_count_ + 1;
  // 指定类的析构函数
  std::shared_ptr&lt;Base&gt; classObjSharePtr(
      class_object, std::bind(&amp;ClassLoader::OnClassObjDeleter&lt;Base&gt;, this,
                              std::placeholders::_1));
  return classObjSharePtr;
}
</pre></div>
</div>
<p>可以看到创建类的时候，类引用计数加1，并且绑定类的析构函数(OnClassObjDeleter)，删除对象的时候让类引用计数减1。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Base</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">ClassLoader</span><span class="p">::</span><span class="n">OnClassObjDeleter</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullptr</span> <span class="o">==</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="p">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">classobj_ref_count_mutex_</span><span class="p">);</span>
  <span class="n">delete</span> <span class="n">obj</span><span class="p">;</span>
  <span class="o">--</span><span class="n">classobj_ref_count_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们先简单的分析下ClassLoaderManager，最后再分析utility。</p>
</div>
<div class="section" id="classloadermanager">
<h3>ClassLoaderManager<a class="headerlink" href="#classloadermanager" title="Permalink to this headline"></a></h3>
<p>类加载器管理实际上是管理不同的classloader，而不同的libpath对应不同的classloader。ClassLoaderManager主要的数据结构其实如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">ClassLoader</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">libpath_loader_map_</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>其中”libpath_loader_map_”为map结构，在”LoadLibrary”的时候赋值，<strong>key为library_path，而value为ClassLoader</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool ClassLoaderManager::LoadLibrary(const std::string&amp; library_path) {
  std::lock_guard&lt;std::mutex&gt; lck(libpath_loader_map_mutex_);
  if (!IsLibraryValid(library_path)) {
    // 赋值
    libpath_loader_map_[library_path] =
        new class_loader::ClassLoader(library_path);
  }
  return IsLibraryValid(library_path);
}
</pre></div>
</div>
<p>也就是说”ClassLoaderManager”对ClassLoader进行保存和管理。</p>
<p>最后我们分析下utility具体的实现，utility分为2部分，一部分为ClassFactory，一部分为工具函数（class_loader_utility.cc）</p>
</div>
<div class="section" id="classfactory">
<h3>ClassFactory<a class="headerlink" href="#classfactory" title="Permalink to this headline"></a></h3>
<p>可以看到有如下继承关系”ClassFactory -&gt; AbstractClassFactory -&gt; AbstractClassFactoryBase”，其中”ClassFactory”和”AbstractClassFactory”为模板类，主要的实现在”AbstractClassFactoryBase”中，我们逐个分析：<br />
首先是类初始化，指定了”relative_library_path_”, “base_class_name_”, “class_name_”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AbstractClassFactoryBase</span><span class="p">::</span><span class="n">AbstractClassFactoryBase</span><span class="p">(</span>
    <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">base_class_name</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">relative_library_path_</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span>
      <span class="n">base_class_name_</span><span class="p">(</span><span class="n">base_class_name</span><span class="p">),</span>
      <span class="n">class_name_</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p>设置OwnedClassLoader，而”RemoveOwnedClassLoader”同理。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">AbstractClassFactoryBase</span><span class="p">::</span><span class="n">AddOwnedClassLoader</span><span class="p">(</span><span class="n">ClassLoader</span><span class="o">*</span> <span class="n">loader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">find</span><span class="p">(</span><span class="n">relative_class_loaders_</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">relative_class_loaders_</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="n">loader</span><span class="p">)</span> <span class="o">==</span> <span class="n">relative_class_loaders_</span><span class="o">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">relative_class_loaders_</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">loader</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>classloader是否属于该classFactory</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">AbstractClassFactoryBase</span><span class="p">::</span><span class="n">IsOwnedBy</span><span class="p">(</span><span class="n">const</span> <span class="n">ClassLoader</span><span class="o">*</span> <span class="n">loader</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ClassLoader</span><span class="o">*&gt;</span><span class="p">::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">find</span><span class="p">(</span>
      <span class="n">relative_class_loaders_</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">relative_class_loaders_</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">loader</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">relative_class_loaders_</span><span class="o">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>也是说ClassFactory能够生产一个路径下的所有类，一个ClassFactory可能有好几个ClassLoader，分为base_class_name和class_name。</p>
</div>
<div class="section" id="id10">
<h3>工具函数<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h3>
<p>接下来我们看”class_loader_utility.cc”的实现，文件中实现了很多函数，这个分析如下：</p>
<p>创建对象(CreateClassObj)的具体实现如下，先找到类对应的factory，然后通过factory创建对象。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Base</span><span class="o">&gt;</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">CreateClassObj</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">ClassLoader</span><span class="o">*</span> <span class="n">loader</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GetClassFactoryMapMapMutex</span><span class="p">()</span><span class="o">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="n">ClassClassFactoryMap</span><span class="o">&amp;</span> <span class="n">factoryMap</span> <span class="o">=</span>
      <span class="n">GetClassFactoryMapByBaseClass</span><span class="p">(</span><span class="n">typeid</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">());</span>
  <span class="n">AbstractClassFactory</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;*</span> <span class="n">factory</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">factoryMap</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span> <span class="o">!=</span> <span class="n">factoryMap</span><span class="o">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">factory</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">utility</span><span class="p">::</span><span class="n">AbstractClassFactory</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;*&gt;</span><span class="p">(</span>
        <span class="n">factoryMap</span><span class="p">[</span><span class="n">class_name</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">GetClassFactoryMapMapMutex</span><span class="p">()</span><span class="o">.</span><span class="n">unlock</span><span class="p">();</span>

  <span class="n">Base</span><span class="o">*</span> <span class="n">classobj</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">factory</span> <span class="o">&amp;&amp;</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">IsOwnedBy</span><span class="p">(</span><span class="n">loader</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">classobj</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">CreateObj</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">classobj</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注册类到factory</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Derived</span><span class="p">,</span> <span class="n">typename</span> <span class="n">Base</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">RegisterClass</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">class_name</span><span class="p">,</span>
                   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">base_class_name</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;registerclass:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">class_name</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">base_class_name</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;,&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">GetCurLoadingLibraryName</span><span class="p">();</span>

  <span class="n">utility</span><span class="p">::</span><span class="n">AbstractClassFactory</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;*</span> <span class="n">new_class_factrory_obj</span> <span class="o">=</span>
      <span class="n">new</span> <span class="n">utility</span><span class="p">::</span><span class="n">ClassFactory</span><span class="o">&lt;</span><span class="n">Derived</span><span class="p">,</span> <span class="n">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">base_class_name</span><span class="p">);</span>
  <span class="n">new_class_factrory_obj</span><span class="o">-&gt;</span><span class="n">AddOwnedClassLoader</span><span class="p">(</span><span class="n">GetCurActiveClassLoader</span><span class="p">());</span>
  <span class="n">new_class_factrory_obj</span><span class="o">-&gt;</span><span class="n">SetRelativeLibraryPath</span><span class="p">(</span><span class="n">GetCurLoadingLibraryName</span><span class="p">());</span>

  <span class="n">GetClassFactoryMapMapMutex</span><span class="p">()</span><span class="o">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="n">ClassClassFactoryMap</span><span class="o">&amp;</span> <span class="n">factory_map</span> <span class="o">=</span>
      <span class="n">GetClassFactoryMapByBaseClass</span><span class="p">(</span><span class="n">typeid</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">());</span>
  <span class="n">factory_map</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_class_factrory_obj</span><span class="p">;</span>
  <span class="n">GetClassFactoryMapMapMutex</span><span class="p">()</span><span class="o">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>查找classloader中所有类的名称</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Base</span><span class="o">&gt;</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">GetValidClassNames</span><span class="p">(</span><span class="n">ClassLoader</span><span class="o">*</span> <span class="n">loader</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">GetClassFactoryMapMapMutex</span><span class="p">());</span>

  <span class="n">ClassClassFactoryMap</span><span class="o">&amp;</span> <span class="n">factoryMap</span> <span class="o">=</span>
      <span class="n">GetClassFactoryMapByBaseClass</span><span class="p">(</span><span class="n">typeid</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">());</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">classes</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">auto</span><span class="o">&amp;</span> <span class="n">class_factory</span> <span class="p">:</span> <span class="n">factoryMap</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AbstractClassFactoryBase</span><span class="o">*</span> <span class="n">factory</span> <span class="o">=</span> <span class="n">class_factory</span><span class="o">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">factory</span> <span class="o">&amp;&amp;</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">IsOwnedBy</span><span class="p">(</span><span class="n">loader</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">classes</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">class_factory</span><span class="o">.</span><span class="n">first</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">classes</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>加载类，通过指定的classloader加载指定路径下的库。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">LoadLibrary</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">library_path</span><span class="p">,</span><span class="w"> </span><span class="n">ClassLoader</span><span class="o">*</span><span class="w"> </span><span class="n">loader</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 类是否已经被加载，如果被加载则对应的class_factory加上依赖的class_loader  </span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsLibraryLoadedByAnybody</span><span class="p">(</span><span class="n">library_path</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ClassFactoryVector</span><span class="w"> </span><span class="n">lib_class_factory_objs</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">GetAllClassFactoryObjectsOfLibrary</span><span class="p">(</span><span class="n">library_path</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">class_factory_obj</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lib_class_factory_objs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">class_factory_obj</span><span class="o">-&gt;</span><span class="n">AddOwnedClassLoader</span><span class="p">(</span><span class="n">loader</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">PocoLibraryPtr</span><span class="w"> </span><span class="n">poco_library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="w"> </span><span class="n">loader_mutex</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lck</span><span class="p">(</span><span class="n">loader_mutex</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 设置当前激活的classloader, 当前加载库路径</span>
<span class="w">      </span><span class="n">SetCurActiveClassLoader</span><span class="p">(</span><span class="n">loader</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">SetCurLoadingLibraryName</span><span class="p">(</span><span class="n">library_path</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 创建poco_library</span>
<span class="w">      </span><span class="n">poco_library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PocoLibraryPtr</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Poco</span><span class="o">::</span><span class="n">SharedLibrary</span><span class="p">(</span><span class="n">library_path</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Poco</span><span class="o">::</span><span class="n">LibraryLoadException</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SetCurLoadingLibraryName</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">SetCurActiveClassLoader</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;poco LibraryLoadException: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Poco</span><span class="o">::</span><span class="n">LibraryAlreadyLoadedException</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SetCurLoadingLibraryName</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">SetCurActiveClassLoader</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;poco LibraryAlreadyLoadedException: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Poco</span><span class="o">::</span><span class="n">NotFoundException</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SetCurLoadingLibraryName</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">SetCurActiveClassLoader</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;poco NotFoundException: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">SetCurLoadingLibraryName</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">SetCurActiveClassLoader</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">poco_library</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;poco shared library failed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">library_path</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">num_lib_objs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetAllClassFactoryObjectsOfLibrary</span><span class="p">(</span><span class="n">library_path</span><span class="p">).</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num_lib_objs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AWARN</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Class factory objs counts is 0, maybe registerclass failed.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lck</span><span class="p">(</span><span class="n">GetLibPathPocoShareLibMutex</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">LibpathPocolibVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">opened_libraries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetLibPathPocoShareLibVector</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 保存加载路径和对应的poco_library</span>
<span class="w">  </span><span class="n">opened_libraries</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">PocoLibraryPtr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">library_path</span><span class="p">,</span><span class="w"> </span><span class="n">poco_library</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>// TODO(zero)： 下面这2个问题目前还没有想到答案</p>
<ol class="arabic simple">
<li><p>通过Poco::SharedLibrary(path)动态加载类，但是加载的类保存在对应的opened_libraries中，又是如何利用这个opened_libraries的呢？？？</p></li>
<li><p>先通过”poco_library = PocoLibraryPtr(new Poco::SharedLibrary(library_path))”加载类，但是最后直接通过new创建出类”Base* CreateObj() const { return new ClassObject; }”是通过如何实现的呢？？？</p></li>
</ol>
<p>上面我们分析了classloader动态的加载并且创建类，而在mainboard中通过动态的加载module，并且调用模块的Initialize方法，实现模块的初始化。下面我们看下模块的初始化过程。</p>
</div>
</div>
<div class="section" id="component-cyber">
<h2>component(cyber组件)<a class="headerlink" href="#component-cyber" title="Permalink to this headline"></a></h2>
<p>我们先看下component的目录结构。</p>
<div class="section" id="id11">
<h3>目录结构<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h3>
<p>可以看到cyber组件分为2类： 普通组件和定时组件，而二者都继承至基础组件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.
├── BUILD
├── component_base.h             // 基础组件
├── component.h                  // 组件
├── component_test.cc
├── timer_component.cc           // 定时组件  
├── timer_component.h
└── timer_component_test.cc
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>基础组件<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h3>
<p>我们先看下基础组件中实现了什么，也就是”component_base.h”中实现了什么？”component_base.h”实现了”ComponentBase”类，下面我们逐步分析”ComponentBase”类的public方法。</p>
<p><strong>Initialize方法</strong><br />
Initialize方法在派生类中重写了，这里有2个Initialize方法，分别对应上述所说的2种类型的组件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">virtual</span> <span class="nb">bool</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">const</span> <span class="n">ComponentConfig</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">false</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">virtual</span> <span class="nb">bool</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">const</span> <span class="n">TimerComponentConfig</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">false</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p><strong>Shutdown方法</strong>
用于关闭cyber模块。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">virtual</span> <span class="n">void</span> <span class="n">Shutdown</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_shutdown_</span><span class="o">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">true</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span><span class="o">&amp;</span> <span class="n">reader</span> <span class="p">:</span> <span class="n">readers_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">reader</span><span class="o">-&gt;</span><span class="n">Shutdown</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">scheduler</span><span class="p">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">RemoveTask</span><span class="p">(</span><span class="n">node_</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">());</span>
  <span class="p">}</span>
</pre></div>
</div>
<p><strong>GetProtoConfig方法</strong><br />
获取protobuf格式的配置</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="nb">bool</span> <span class="n">GetProtoConfig</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">config</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">common</span><span class="p">::</span><span class="n">GetProtoFromFile</span><span class="p">(</span><span class="n">config_file_path_</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>看完公有方法，下面我们看下私有方法。有些简单的方法这里就不详细说了，主要看下”LoadConfigFiles方法”，有2个”LoadConfigFiles”方法这里只介绍第一个：<br />
<strong>LoadConfigFiles方法</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">LoadConfigFiles</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ComponentConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 获取配置文件路径</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">config</span><span class="p">.</span><span class="n">config_file_path</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">config_file_path</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">config_file_path_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">GetAbsolutePath</span><span class="p">(</span><span class="n">common</span><span class="o">::</span><span class="n">WorkRoot</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                    </span><span class="n">config</span><span class="p">.</span><span class="n">config_file_path</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">config_file_path_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">config_file_path</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 设置flag文件路径</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">config</span><span class="p">.</span><span class="n">flag_file_path</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">flag_file_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">flag_file_path</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flag_file_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flag_file_path</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="n">common</span><span class="o">::</span><span class="n">GetAbsolutePath</span><span class="p">(</span><span class="n">common</span><span class="o">::</span><span class="n">WorkRoot</span><span class="p">(),</span><span class="w"> </span><span class="n">flag_file_path</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">google</span><span class="o">::</span><span class="n">SetCommandLineOption</span><span class="p">(</span><span class="s">&quot;flagfile&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">flag_file_path</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>私有成员变量</strong><br />
最后我们在分析下私有成员变量，也就是说每个组件(component)会自动创建一个节点(node)，并且可以挂载多个reader。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">std</span><span class="p">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">is_shutdown_</span> <span class="o">=</span> <span class="p">{</span><span class="n">false</span><span class="p">};</span>
  <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">node_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">config_file_path_</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ReaderBase</span><span class="o">&gt;&gt;</span> <span class="n">readers_</span><span class="p">;</span>
</pre></div>
</div>
<p>下面我们开始分析component组件，也就是Component类。</p>
</div>
<div class="section" id="id13">
<h3>Component类<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h3>
<p>Component类都需要实现”Initialize”和”Process”2个方法，所以planning,routing,perception等模块都需要实现这2个方法。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">M0</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ComponentBase</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">Component</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="o">~</span><span class="n">Component</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Initialize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ComponentConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Proc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>我们接着看下这2个方法是如何实现的，先看”Process”方法。<br />
<strong>Process方法</strong><br />
可以看到Process方法比较简单，先判断模块是否关闭，然后执行”Proc”方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">M0</span><span class="p">,</span> <span class="n">typename</span> <span class="n">M1</span><span class="o">&gt;</span>
<span class="nb">bool</span> <span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">NullType</span><span class="p">,</span> <span class="n">NullType</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Process</span><span class="p">(</span>
    <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span> <span class="n">msg0</span><span class="p">,</span> <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;&amp;</span> <span class="n">msg1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_shutdown_</span><span class="o">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Proc</span><span class="p">(</span><span class="n">msg0</span><span class="p">,</span> <span class="n">msg1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Initialize方法</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">M0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">M1</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="o">&gt;::</span><span class="n">Initialize</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ComponentConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 创建node节点</span>
<span class="w">  </span><span class="n">node_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 加载配置</span>
<span class="w">  </span><span class="n">LoadConfigFiles</span><span class="p">(</span><span class="n">config</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 订阅消息数和reader个数要匹配</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">readers_size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Invalid config file: too few readers.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 初始化，在基类(ComponentBase)中实现</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Init</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Component Init() failed.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_reality_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalData</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IsRealityMode</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 创建reader1</span>
<span class="w">  </span><span class="n">ReaderConfig</span><span class="w"> </span><span class="n">reader_cfg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">channel_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">channel</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">qos_profile</span><span class="p">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">qos_profile</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">pending_queue_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">pending_queue_size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">reader1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="k">template</span><span class="w"> </span><span class="n">CreateReader</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader_cfg</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 创建reader0</span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">channel_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">channel</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">qos_profile</span><span class="p">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">qos_profile</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">pending_queue_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">pending_queue_size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">reader0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// is_reality_mode模式则直接创建</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_likely</span><span class="p">(</span><span class="n">is_reality_mode</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">reader0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="k">template</span><span class="w"> </span><span class="n">CreateReader</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader_cfg</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 如果不是则创建回调函数</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">blocker1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blocker</span><span class="o">::</span><span class="n">BlockerManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetBlocker</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">channel</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">blocker1</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">blocker1</span><span class="o">-&gt;</span><span class="n">IsPublishedEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="n">msg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blocker1</span><span class="o">-&gt;</span><span class="n">GetLatestPublishedPtr</span><span class="p">();</span><span class="w"></span>
<span class="w">          </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">Process</span><span class="p">(</span><span class="n">msg0</span><span class="p">,</span><span class="w"> </span><span class="n">msg1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Component object has been destroyed.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="n">reader0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="k">template</span><span class="w"> </span><span class="n">CreateReader</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader_cfg</span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reader0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">reader1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Component create reader failed.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 保存readers</span>
<span class="w">  </span><span class="n">readers_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">reader0</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">readers_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">reader1</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">is_reality_mode</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">sched</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scheduler</span><span class="o">::</span><span class="n">Instance</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">self</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg0</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">Process</span><span class="p">(</span><span class="n">msg0</span><span class="p">,</span><span class="w"> </span><span class="n">msg1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Component object has been destroyed.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data</span><span class="o">::</span><span class="n">VisitorConfig</span><span class="o">&gt;</span><span class="w"> </span><span class="n">config_list</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">readers_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">config_list</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">ChannelId</span><span class="p">(),</span><span class="w"> </span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">PendingQueueSize</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">dv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">data</span><span class="o">::</span><span class="n">DataVisitor</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">config_list</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 创建协程类</span>
<span class="w">  </span><span class="n">croutine</span><span class="o">::</span><span class="n">RoutineFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">croutine</span><span class="o">::</span><span class="n">CreateRoutineFactory</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">dv</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">CreateTask</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>component动态加载<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h3>
<p>cyber主函数在”ModuleController::Init()”进行模块的加载，具体的加载过程在”ModuleController::LoadModule”中。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">ModuleController::LoadModule</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">DagConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dag_config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">work_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">common</span><span class="o">::</span><span class="n">WorkRoot</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">module_config</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">dag_config</span><span class="p">.</span><span class="n">module_config</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 1. 加载动态库</span>
<span class="w">    </span><span class="n">class_loader_manager_</span><span class="p">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="n">load_path</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 2. 加载消息触发模块</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">module_config</span><span class="p">.</span><span class="n">components</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">class_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">component</span><span class="p">.</span><span class="n">class_name</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 3. 创建对象</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">class_loader_manager_</span><span class="p">.</span><span class="n">CreateClassObj</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="p">(</span><span class="n">class_name</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 4. 调用对象的Initialize方法</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">Initialize</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="n">config</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">component_list_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">base</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 5. 加载定时触发模块</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">module_config</span><span class="p">.</span><span class="n">timer_components</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 6. 创建对象</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">class_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">component</span><span class="p">.</span><span class="n">class_name</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">class_loader_manager_</span><span class="p">.</span><span class="n">CreateClassObj</span><span class="o">&lt;</span><span class="n">ComponentBase</span><span class="o">&gt;</span><span class="p">(</span><span class="n">class_name</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 7. 调用对象的Initialize方法</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">Initialize</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="n">config</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">component_list_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">base</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>模块首先通过classloader加载到内存，然后创建对象，并且调用模块的初始化方法。component中每个模块都设计为可以动态加载和卸载，可以实时在线的开启和关闭模块，实现的方式是通过classloader来进行动态的加载动态库。</p>
</div>
<div class="section" id="id15">
<h3>component初始化<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h3>
<p>component一共有4个模板类，分别对应接收0-3个消息，（这里有疑问为什么没有4个消息的模板类，是漏掉了吗？）我们这里主要分析2个消息的情况，其它的可以类推。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">M0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">M1</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="o">&gt;::</span><span class="n">Initialize</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ComponentConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 创建Node</span>
<span class="w">  </span><span class="n">node_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">LoadConfigFiles</span><span class="p">(</span><span class="n">config</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. 调用用户自定义初始化Init()</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Init</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Component Init() failed.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_reality_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalData</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IsRealityMode</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">ReaderConfig</span><span class="w"> </span><span class="n">reader_cfg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">channel_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">channel</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">qos_profile</span><span class="p">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">qos_profile</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">reader_cfg</span><span class="p">.</span><span class="n">pending_queue_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">readers</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">pending_queue_size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 3. 创建reader1</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">reader1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="k">template</span><span class="w"> </span><span class="n">CreateReader</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader_cfg</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 4. 创建reader0</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_likely</span><span class="p">(</span><span class="n">is_reality_mode</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">reader0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="k">template</span><span class="w"> </span><span class="n">CreateReader</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader_cfg</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="n">readers_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">reader0</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">readers_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">reader1</span><span class="p">));</span><span class="w"></span>


<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">sched</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scheduler</span><span class="o">::</span><span class="n">Instance</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 5. 创建回调，回调执行Proc()</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">Component</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">self</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg0</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">Process</span><span class="p">(</span><span class="n">msg0</span><span class="p">,</span><span class="w"> </span><span class="n">msg1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AERROR</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Component object has been destroyed.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data</span><span class="o">::</span><span class="n">VisitorConfig</span><span class="o">&gt;</span><span class="w"> </span><span class="n">config_list</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">readers_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">config_list</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">ChannelId</span><span class="p">(),</span><span class="w"> </span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">PendingQueueSize</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 6. 创建数据访问器</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">dv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">data</span><span class="o">::</span><span class="n">DataVisitor</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">config_list</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 7. 创建协程，协程绑定回调func（执行proc）。数据访问器dv在收到订阅数据之后，唤醒绑定的协程执行任务，任务执行完成之后继续休眠。</span>
<span class="w">  </span><span class="n">croutine</span><span class="o">::</span><span class="n">RoutineFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">croutine</span><span class="o">::</span><span class="n">CreateRoutineFactory</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">dv</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">CreateTask</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>总结以下component的流程。</p>
<ol class="arabic simple">
<li><p>创建node节点（1个component只能有1个node节点，之后用户可以用node_在init中自己创建reader或writer）。</p></li>
<li><p>调用用户自定义的初始化函数Init()（子类的Init方法）</p></li>
<li><p>创建reader，订阅几个消息就创建几个reader。</p></li>
<li><p>创建回调函数，实际上是执行用户定义算法Proc()函数</p></li>
<li><p>创建数据访问器，数据访问器的用途为接收数据（融合多个通道的数据），唤醒对应的协程执行任务。</p></li>
<li><p>创建协程任务绑定回调函数，并且绑定数据访问器到对应的协程任务，用于唤醒对应的任务。</p></li>
</ol>
<p>因为之前对cyber数据的收发流程有了一个简单的介绍，这里我们会分别介绍如何创建协程、如何在scheduler注册任务并且绑定Notify。也就是说，为了方便理解，你可以认为数据通过DataDispatcher已经分发到了对应的DataVisitor中，<strong>接下来我们只分析如何从DataVisitor中取数据，并且触发对应的协程执行回调任务</strong>。</p>
</div>
<div class="section" id="id16">
<h3>创建协程<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h3>
<p>创建协程对应上述代码</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">croutine</span><span class="o">::</span><span class="n">RoutineFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">croutine</span><span class="o">::</span><span class="n">CreateRoutineFactory</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">dv</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>接下来我们查看下如何创建协程呢？协程通过工厂模式方法创建，里面包含一个回调函数和一个dv（数据访问器）。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">M0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">M1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">RoutineFactory</span><span class="w"> </span><span class="n">CreateRoutineFactory</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">F</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">data</span><span class="o">::</span><span class="n">DataVisitor</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">dv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">RoutineFactory</span><span class="w"> </span><span class="n">factory</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 工厂中设置DataVisitor</span>
<span class="w">  </span><span class="n">factory</span><span class="p">.</span><span class="n">SetDataVisitor</span><span class="p">(</span><span class="n">dv</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">factory</span><span class="p">.</span><span class="n">create_routine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">msg0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">msg1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">CRoutine</span><span class="o">::</span><span class="n">GetCurrentRoutine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_state</span><span class="p">(</span><span class="n">RoutineState</span><span class="o">::</span><span class="n">DATA_WAIT</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 2. 从DataVisitor中获取数据</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dv</span><span class="o">-&gt;</span><span class="n">TryFetch</span><span class="p">(</span><span class="n">msg0</span><span class="p">,</span><span class="w"> </span><span class="n">msg1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// 3. 执行回调函数</span>
<span class="w">          </span><span class="n">f</span><span class="p">(</span><span class="n">msg0</span><span class="p">,</span><span class="w"> </span><span class="n">msg1</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="c1">// 4. 继续休眠</span>
<span class="w">          </span><span class="n">CRoutine</span><span class="o">::</span><span class="n">Yield</span><span class="p">(</span><span class="n">RoutineState</span><span class="o">::</span><span class="n">READY</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">CRoutine</span><span class="o">::</span><span class="n">Yield</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">factory</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述过程总结如下：</p>
<ol class="arabic simple">
<li><p>工厂中设置DataVisitor</p></li>
<li><p>工厂中创建设置协程执行函数，回调包括3个步骤：从DataVisitor中获取数据，执行回调函数，继续休眠。</p></li>
</ol>
</div>
<div class="section" id="id17">
<h3>创建调度任务<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h3>
<p>创建调度任务是在过程”Component::Initialize”中完成。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">CreateTask</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>我们接着分析如何在Scheduler中创建任务。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">Scheduler::CreateTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DataVisitorBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">visitor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 根据名称创建任务ID</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">task_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalData</span><span class="o">::</span><span class="n">RegisterTaskName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">cr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">CRoutine</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_id</span><span class="p">(</span><span class="n">task_id</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;create croutine: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 2. 分发协程任务</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">DispatchTask</span><span class="p">(</span><span class="n">cr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 3. 注册Notify唤醒任务</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">visitor</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">visitor</span><span class="o">-&gt;</span><span class="n">RegisterNotifyCallback</span><span class="p">([</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">task_id</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_unlikely</span><span class="p">(</span><span class="n">stop_</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">NotifyProcessor</span><span class="p">(</span><span class="n">task_id</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="timercomponent">
<h3>TimerComponent<a class="headerlink" href="#timercomponent" title="Permalink to this headline"></a></h3>
<p>实际上Component分为2类：一类是上面介绍的消息驱动的Component，第二类是定时调用的TimerComponent。定时调度模块没有绑定消息收发，需要用户自己创建reader来读取消息，如果需要读取多个消息，可以创建多个reader。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">TimerComponent::Initialize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TimerComponentConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 创建node</span>
<span class="w">  </span><span class="n">node_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">LoadConfigFiles</span><span class="p">(</span><span class="n">config</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 2. 调用用户自定义初始化函数</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Init</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TimerComponent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">TimerComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 3. 创建定时器，定时调用&quot;Proc()&quot;函数</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">self</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">Proc</span><span class="p">();</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">timer_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Timer</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">interval</span><span class="p">(),</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">timer_</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>总结一下TimerComponent的执行流程如下。</p>
<ol class="arabic simple">
<li><p>创建Node</p></li>
<li><p>调用用户自定义初始化函数</p></li>
<li><p>创建定时器，定时调用”Proc()”函数</p></li>
</ol>
<p>上述就是Component模块的调用流程。为了弄清楚消息的调用过程，下面我们分析”DataDispatcher”和”DataVisitor”。</p>
</div>
</div>
<div class="section" id="datavisitordatadispatcher">
<h2>DataVisitor和DataDispatcher<a class="headerlink" href="#datavisitordatadispatcher" title="Permalink to this headline"></a></h2>
<p>DataDispather（消息分发器）发布消息，DataDispather是一个单例，所有的数据分发都在数据分发器中进行，DataDispather会把数据放到对应的缓存中，然后Notify(通知)对应的协程（实际上这里调用的是DataVisitor中注册的Notify）去处理消息。<br />
DataVisitor（消息访问器）是一个辅助的类，<strong>一个数据处理过程对应一个DataVisitor，通过在DataVisitor中注册Notify（唤醒对应的协程，协程执行绑定的回调函数），并且注册对应的Buffer到DataDispather</strong>，这样在DataDispather的时候会通知对应的DataVisitor去唤醒对应的协程。<br />
也就是说DataDispather（消息分发器）发布对应的消息到DataVisitor，DataVisitor（消息访问器）唤醒对应的协程，协程中执行绑定的数据处理回调函数。</p>
<div class="section" id="datavisitor">
<h3>DataVisitor数据访问器<a class="headerlink" href="#datavisitor" title="Permalink to this headline"></a></h3>
<p>DataVisitor继承至DataVisitorBase类，先看DataVisitorBase类的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DataVisitorBase</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 初始化的时候创建一个Notifier</span>
<span class="w">  </span><span class="n">DataVisitorBase</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">notifier_</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Notifier</span><span class="p">())</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. 设置注册回调</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">RegisterNotifyCallback</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">notifier_</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 3. 下一次消息的下标</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">next_msg_index_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 4. DataNotifier单例</span>
<span class="w">  </span><span class="n">DataNotifier</span><span class="o">*</span><span class="w"> </span><span class="n">data_notifier_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DataNotifier</span><span class="o">::</span><span class="n">Instance</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Notifier</span><span class="o">&gt;</span><span class="w"> </span><span class="n">notifier_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>可以看到DataVisitorBase创建了一个”Notifier”类，并且提供注册回调的接口。同时还引用了”DataNotifier::Instance()”单例。</p>
<p>接下来看”DataVisitor”类的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">M0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">M1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">M2</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">DataVisitor</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="p">,</span><span class="w"> </span><span class="n">NullType</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DataVisitorBase</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">DataVisitor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VisitorConfig</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">configs</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">buffer_m0_</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">channel_id</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">new</span><span class="w"> </span><span class="n">BufferType</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">queue_size</span><span class="p">)),</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer_m1_</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">channel_id</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">new</span><span class="w"> </span><span class="n">BufferType</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">queue_size</span><span class="p">)),</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer_m2_</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">channel_id</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">new</span><span class="w"> </span><span class="n">BufferType</span><span class="o">&lt;</span><span class="n">M2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">queue_size</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 1. 在DataDispatcher中增加ChannelBuffer</span>
<span class="w">    </span><span class="n">DataDispatcher</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddBuffer</span><span class="p">(</span><span class="n">buffer_m0_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">DataDispatcher</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddBuffer</span><span class="p">(</span><span class="n">buffer_m1_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">DataDispatcher</span><span class="o">&lt;</span><span class="n">M2</span><span class="o">&gt;::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddBuffer</span><span class="p">(</span><span class="n">buffer_m2_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 2. 在DataNotifier::Instance()中增加创建好的Notifier</span>
<span class="w">    </span><span class="n">data_notifier_</span><span class="o">-&gt;</span><span class="n">AddNotifier</span><span class="p">(</span><span class="n">buffer_m0_</span><span class="p">.</span><span class="n">channel_id</span><span class="p">(),</span><span class="w"> </span><span class="n">notifier_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 3. 对接收到的消息进行数据融合</span>
<span class="w">    </span><span class="n">data_fusion_</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">fusion</span><span class="o">::</span><span class="n">AllLatest</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buffer_m0_</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_m1_</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_m2_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">TryFetch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">m0</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w">  </span><span class="c1">// NOLINT</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M2</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">m2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                         </span><span class="c1">// NOLINT</span>
<span class="w">    </span><span class="c1">// 4. 获取融合数据</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_fusion_</span><span class="o">-&gt;</span><span class="n">Fusion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_msg_index_</span><span class="p">,</span><span class="w"> </span><span class="n">m0</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">next_msg_index_</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">fusion</span><span class="o">::</span><span class="n">DataFusion</span><span class="o">&lt;</span><span class="n">M0</span><span class="p">,</span><span class="w"> </span><span class="n">M1</span><span class="p">,</span><span class="w"> </span><span class="n">M2</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">data_fusion_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ChannelBuffer</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer_m0_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ChannelBuffer</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer_m1_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ChannelBuffer</span><span class="o">&lt;</span><span class="n">M2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer_m2_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>总结一下DataVisitor中实现的功能。</p>
<ol class="arabic simple">
<li><p>在DataDispatcher中添加订阅的ChannelBuffer</p></li>
<li><p>在DataNotifier中增加对应通道的Notifier</p></li>
<li><p>通过DataVisitor获取数据并进行融合</p></li>
</ol>
<p><strong>这里注意</strong></p>
<ol class="arabic simple">
<li><p>如果DataVisitor只访问一个消息，则不会对消息进行融合，如果DataVisitor访问2个以上的数据，那么需要进行融合，并且注册融合回调。之后CacheBuffer中会调用融合回调进行数据处理，而不会把数据放入CacheBuffer中。</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1. 只有一个消息的时候直接从Buffer中获取消息</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">TryFetch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">m0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// NOLINT</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_msg_index_</span><span class="p">,</span><span class="w"> </span><span class="n">m0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">next_msg_index_</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="c1">// 2. 当有2个消息的时候，从融合buffer中读取消息</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">TryFetch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">m0</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">m1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// NOLINT</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_fusion_</span><span class="o">-&gt;</span><span class="n">Fusion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_msg_index_</span><span class="p">,</span><span class="w"> </span><span class="n">m0</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">next_msg_index_</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>实际上如果有多个消息的时候，会以第1个消息为基准，然后把其它消息的最新消息一起放入融合好的buffer_fusion_。</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">AllLatest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ChannelBuffer</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer_0</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">ChannelBuffer</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer_1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">buffer_m0_</span><span class="p">(</span><span class="n">buffer_0</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer_m1_</span><span class="p">(</span><span class="n">buffer_1</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer_fusion_</span><span class="p">(</span><span class="n">buffer_m0_</span><span class="p">.</span><span class="n">channel_id</span><span class="p">(),</span><span class="w"></span>
<span class="w">                       </span><span class="k">new</span><span class="w"> </span><span class="n">CacheBuffer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">FusionDataType</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">                           </span><span class="n">buffer_0</span><span class="p">.</span><span class="n">Buffer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Capacity</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="kt">uint64_t</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 1. 注意这里只注册了buffer_m0_的回调，其它的消息还是把消息放入CacheBuffer。  </span>
<span class="w">    </span><span class="c1">// 2. 而buffer_m0_直接调用回调函数，把消息放入融合的CacheBuffer。  </span>
<span class="w">    </span><span class="n">buffer_m0_</span><span class="p">.</span><span class="n">Buffer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFusionCallback</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M0</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">m0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">M1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m1</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">buffer_m1_</span><span class="p">.</span><span class="n">Latest</span><span class="p">(</span><span class="n">m1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">FusionDataType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lg</span><span class="p">(</span><span class="n">buffer_fusion_</span><span class="p">.</span><span class="n">Buffer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Mutex</span><span class="p">());</span><span class="w"></span>
<span class="w">          </span><span class="n">buffer_fusion_</span><span class="p">.</span><span class="n">Buffer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Fill</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>DataFusion类是一个虚类，定义了数据融合的接口”Fusion()”，Apollo里只提供了一种数据融合的方式，即以第一个消息的时间为基准，取其它最新的消息，当然也可以在这里实现其它的数据融合方式。</p></li>
</ol>
</div>
<div class="section" id="datadispatcher">
<h3>DataDispatcher数据分发器<a class="headerlink" href="#datadispatcher" title="Permalink to this headline"></a></h3>
<p>接下来我们看DataDispatcher的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">DataDispatcher</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BufferVector</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">CacheBuffer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">~</span><span class="n">DataDispatcher</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 添加ChannelBuffer到buffers_map_</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">AddBuffer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ChannelBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">channel_buffer</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. 分发通道中的消息</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Dispatch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">channel_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 3. DataNotifier单例</span>
<span class="w">  </span><span class="n">DataNotifier</span><span class="o">*</span><span class="w"> </span><span class="n">notifier_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DataNotifier</span><span class="o">::</span><span class="n">Instance</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">buffers_map_mutex_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 4. 哈希表，key为通道id，value为订阅通道消息的CacheBuffer数组。</span>
<span class="w">  </span><span class="n">AtomicHashMap</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span><span class="w"> </span><span class="n">BufferVector</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffers_map_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 5. 单例</span>
<span class="w">  </span><span class="n">DECLARE_SINGLETON</span><span class="p">(</span><span class="n">DataDispatcher</span><span class="p">)</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>总结一下DataDispatcher的实现。</p>
<ol class="arabic simple">
<li><p>添加ChannelBuffer到buffers_map_，key为通道id（topic），value为订阅通道消息的CacheBuffer数组。</p></li>
<li><p>分发通道中的消息。根据通道id，把消息放入对应的CacheBuffer。然后通过DataNotifier::Instance()通知对应的通道。</p></li>
</ol>
<p><strong>如果一个通道(topic)有3个CacheBuffer订阅，那么每次都会往这3个CacheBuffer中写入当前消息的指针。因为消息是共享的，消息访问的时候需要加锁。</strong></p>
<p>那么DataNotifier如何通知对应的Channel的呢？理解清楚了DataNotifier的数据结构，那么也就理解了DataNotifier的原理，DataNotifier保存了</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class DataNotifier {
 public:
  using NotifyVector = std::vector&lt;std::shared_ptr&lt;Notifier&gt;&gt;;
  ~DataNotifier() {}

  void AddNotifier(uint64_t channel_id,
                   const std::shared_ptr&lt;Notifier&gt;&amp; notifier);

  bool Notify(const uint64_t channel_id);

 private:
  std::mutex notifies_map_mutex_;
  // 1. 哈希表，key为通道id，value为Notify数组
  AtomicHashMap&lt;uint64_t, NotifyVector&gt; notifies_map_;

  DECLARE_SINGLETON(DataNotifier)
};
</pre></div>
</div>
<p>DataNotifier中包含一个哈希表，表的key为通道id，表的值为Notify数组，每个DataVisitorBase在初始化的时候会创建一个Notify。</p>
<p>接着我们看下CacheBuffer的实现，CacheBuffer实际上实现了一个缓存队列，主要关注下Fill函数。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Fill</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fusion_callback_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 1. 融合回调</span>
<span class="w">      </span><span class="n">fusion_callback_</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 2. 如果Buffer满，实现循环队列</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Full</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer_</span><span class="p">[</span><span class="n">GetIndex</span><span class="p">(</span><span class="n">head_</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="o">++</span><span class="n">head_</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="o">++</span><span class="n">tail_</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer_</span><span class="p">[</span><span class="n">GetIndex</span><span class="p">(</span><span class="n">tail_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="o">++</span><span class="n">tail_</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>ChannelBuffer是CacheBuffer的封装，主要看下获取值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>template &lt;typename T&gt;
bool ChannelBuffer&lt;T&gt;::Fetch(uint64_t* index,
                             std::shared_ptr&lt;T&gt;&amp; m) {  // NOLINT
  std::lock_guard&lt;std::mutex&gt; lock(buffer_-&gt;Mutex());
  if (buffer_-&gt;Empty()) {
    return false;
  }

  if (*index == 0) {
    *index = buffer_-&gt;Tail();
  // 1. 为什么是判断最新的加1，而不是大于？？？
  } else if (*index == buffer_-&gt;Tail() + 1) {
    return false;
  } else if (*index &lt; buffer_-&gt;Head()) {
    auto interval = buffer_-&gt;Tail() - *index;
    AWARN &lt;&lt; &quot;channel[&quot; &lt;&lt; GlobalData::GetChannelById(channel_id_) &lt;&lt; &quot;] &quot;
          &lt;&lt; &quot;read buffer overflow, drop_message[&quot; &lt;&lt; interval &lt;&lt; &quot;] pre_index[&quot;
          &lt;&lt; *index &lt;&lt; &quot;] current_index[&quot; &lt;&lt; buffer_-&gt;Tail() &lt;&lt; &quot;] &quot;;
    *index = buffer_-&gt;Tail();
  }
  m = buffer_-&gt;at(*index);
  return true;
}
</pre></div>
</div>
<p>疑问：这里获取的id是消息的累计数量，也就是说从开始到结束发送了多少的消息。如果消息大于最新的id，而不是等于最大值+1，则会返回错误的值？？？</p>
</div>
<div class="section" id="data">
<h3>data目录总结<a class="headerlink" href="#data" title="Permalink to this headline"></a></h3>
<p>通过上述的分析，实际上数据的访问都是通过”DataVisitor”来实现，数据的分发通过”DataDispatcher”来实现。reader中也是通过DataVisitor来访问数据，在reader中订阅对应的DataDispatcher。也就是说如果你要订阅一个通道，首先是在reader中注册消息的topic，绑定DataDispatcher，之后对应通道的消息到来之后，触发DataDispatcher分发消息，而DataDispatcher通过DataVisitor中的Notify唤醒协程，从DataVisitor中获取消息，并执行协程中绑定的回调函数，以上就是整个消息的收发过程。</p>
<p>疑问： Reader中还拷贝了一份数据到Blocker中，实际上数据的处理过程并不需要缓存数据，参考”Planning”模块中的实现都是在回调函数中把数据拷贝到指针中。看注释是说Blocker是用来仿真的？？？后面需要确实下。以下是Planning模块中回调函数中拷贝数据的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">traffic_light_reader_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_</span><span class="o">-&gt;</span><span class="n">CreateReader</span><span class="o">&lt;</span><span class="n">TrafficLightDetection</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">FLAGS_traffic_light_detection_topic</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TrafficLightDetection</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">traffic_light</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Received traffic light data: run traffic light callback.&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 1. 拷贝消息到指针</span>
<span class="w">        </span><span class="n">traffic_light_</span><span class="p">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="o">*</span><span class="n">traffic_light</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>这里需要注意系统在component中自动帮我们创建了一个DataVisitor，订阅component中的消息，融合获取最新的消息之后，执行Proc回调。需要注意component的第一个消息一定是模块的基准消息来源，也就是模块中最主要的参考消息，不能随便调换顺序。</p>
</div>
</div>
<div class="section" id="node">
<h2>Node介绍<a class="headerlink" href="#node" title="Permalink to this headline"></a></h2>
<p>Node目录中包含了Node对象、Reader对象和Writer对象。Node对象主要对应Ros中的Node节点，在Node节点中可以创建Reader和Writer来订阅和发布消息，需要管理对应的通道注册。</p>
<div class="section" id="id18">
<h3>Node对象<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h3>
</div>
<div class="section" id="reader">
<h3>Reader对象<a class="headerlink" href="#reader" title="Permalink to this headline"></a></h3>
</div>
<div class="section" id="writer">
<h3>Writer对象<a class="headerlink" href="#writer" title="Permalink to this headline"></a></h3>
</div>
</div>
<div class="section" id="croutine">
<h2>CRoutine协程<a class="headerlink" href="#croutine" title="Permalink to this headline"></a></h2>
<p>协程是用户态的线程，由于进程切换需要用户态到内核态的切换，而协程不需要切换到内核态，因此协程的切换开销比线程低。实际上线程切换的过程如下：</p>
<ol class="arabic simple">
<li><p>保存当前线程的现场到堆栈，寄存器，栈指针</p></li>
<li><p>用户态切换到内核态</p></li>
<li><p>切换到另外一个线程，跳转到栈指针，恢复现场</p></li>
</ol>
<p>一个线程的几种状态: running、sleeping。那么协程需要几种状态呢？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="k">class</span> <span class="nc">RoutineState</span> <span class="p">{</span> <span class="n">READY</span><span class="p">,</span> <span class="n">FINISHED</span><span class="p">,</span> <span class="n">SLEEP</span><span class="p">,</span> <span class="n">IO_WAIT</span><span class="p">,</span> <span class="n">DATA_WAIT</span> <span class="p">};</span>
</pre></div>
</div>
<p>可以看到协程的状态有5种：准备好、结束、睡觉、等待IO、等待数据。</p>
<p>接着看下CRoutine的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CRoutine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">CRoutine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RoutineFunc</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">CRoutine</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// static interfaces</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Yield</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Yield</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RoutineState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetMainContext</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RoutineContext</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">CRoutine</span><span class="w"> </span><span class="o">*</span><span class="nf">GetCurrentRoutine</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="nf">GetMainStack</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// public interfaces</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Acquire</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Release</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// It is caller&#39;s responsibility to check if state_ is valid before calling</span>
<span class="w">  </span><span class="c1">// SetUpdateFlag().</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetUpdateFlag</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// acquire &amp;&amp; release should be called before Resume</span>
<span class="w">  </span><span class="c1">// when work-steal like mechanism used</span>
<span class="w">  </span><span class="n">RoutineState</span><span class="w"> </span><span class="nf">Resume</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">RoutineState</span><span class="w"> </span><span class="nf">UpdateState</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">RoutineContext</span><span class="w"> </span><span class="o">*</span><span class="nf">GetContext</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="nf">GetStack</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Run</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Wake</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">HangUp</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Sleep</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Duration</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sleep_duration</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// getter and setter</span>
<span class="w">  </span><span class="n">RoutineState</span><span class="w"> </span><span class="nf">state</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_state</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RoutineState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_id</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">processor_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_processor_id</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">processor_id</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">priority</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_priority</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">priority</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span><span class="w"> </span><span class="nf">wake_time</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_group_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">group_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">group_name_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group_name</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">group_name</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">group_name_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">CRoutine</span><span class="p">(</span><span class="n">CRoutine</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">CRoutine</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">CRoutine</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span><span class="w"> </span><span class="n">wake_time_</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">RoutineFunc</span><span class="w"> </span><span class="n">func_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">RoutineState</span><span class="w"> </span><span class="n">state_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RoutineContext</span><span class="o">&gt;</span><span class="w"> </span><span class="n">context_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span><span class="w"> </span><span class="n">lock_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATOMIC_FLAG_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span><span class="w"> </span><span class="n">updated_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATOMIC_FLAG_INIT</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_stop_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">processor_id_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">priority_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">id_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">group_name_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="n">CRoutine</span><span class="w"> </span><span class="o">*</span><span class="n">current_routine_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">thread_local</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">main_stack_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>对上述方法做一些归类。</p>
<p>下面总结一下CRoutine的切换流程。</p>
</div>
<div class="section" id="scheduler">
<h2>Scheduler调度<a class="headerlink" href="#scheduler" title="Permalink to this headline"></a></h2>
<p>所谓的调度，一定是系统资源和运行任务的矛盾，如果系统资源足够多，那么就不需要调度了，也没有调度的必要。调度的作用就是在资源有限的情况下，合理利用系统资源，使系统的效率最高。</p>
<div class="section" id="scheduler-instance">
<h3>Scheduler* Instance()<a class="headerlink" href="#scheduler-instance" title="Permalink to this headline"></a></h3>
<p>在”scheduler_factory.cc”中实现了”Scheduler* Instance()”方法，该方法根据”conf”目录中的配置创建不同的调度策略。Cyber中有2种调度策略”SchedulerClassic”和”SchedulerChoreography”。要理解上述2种模型，可以参考go语言中的GPM模型。</p>
<ol class="arabic simple">
<li><p>SchedulerClassic 采用了协程池的概念，协程没有绑定到具体的Processor，所有的协程放在全局的优先级队列中，每次从最高优先级的任务开始执行。</p></li>
<li><p>SchedulerChoreography 采用了本地队列和全局队列相结合的方式，通过”ChoreographyContext”运行本地队列的线程，通过”ClassicContext”来运行全局队列。<br />
疑问： 这里的调度对象为原子指针”std::atomic&lt;Scheduler*&gt; instance”，为什么需要设置内存模型，并且加锁呢？</p></li>
</ol>
</div>
<div class="section" id="id19">
<h3>基本概念<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h3>
</div>
<div class="section" id="gpm">
<h3>1.GPM模型<a class="headerlink" href="#gpm" title="Permalink to this headline"></a></h3>
<p><a class="reference external" href="https://learnku.com/articles/41728">GPM模型</a>是go语言中的概念，G代表协程，P代表执行器，M代表线程。P代表协程执行的环境，一个P绑定一个线程M，协程G根据不同的上下文环境在P中执行，上述的设计解耦了协程和线程，线程和协程都只知道P中，在go语言中还有一个调度器，把具体的协程分配到不同的P中，这样就可以在用户态实现协程的调度，同时执行多个任务。<br />
在go语言早期，只有一个全局的协程队列，每个P都会从全局队列中取任务，然后执行。因为多个P都会去全局队列中取任务，因此会带来并发访问，需要在全局队列中加锁。全局队列调度模型如图。<br />
<img alt="scheduler_classic" src="../../_images/scheduler_classic.jpg" /></p>
<p>上述方法虽然实现了多个任务的调度，但是带来的问题是多个P都会去竞争全局锁，导致效率低下，之后go语言对调度模型做了改善，改善之后每个P都会拥有一个本地队列，P优先从本地队列中取任务执行，如果P中没有任务了，那么P会从全局或者相邻的任务中偷取一半的任务执行，这样带来的好处是不需要全局锁了，每个P都优先执行本地队列。另外调度器还会监视P中的协程，如果协程过长时间阻塞，则会把协程移动到全局队列，以示惩罚。本地队列加全局队列如图。<br />
<img alt="scheduler_chor" src="../../_images/scheduler_chor.jpg" /></p>
<p>理解了GPM模型，下面我们接着看Cyber中的调度器，SchedulerClassic代表着全局队列模型，SchedulerChoreography则代表着本地队列加全局队列模型。SchedulerChoreography模型和go语言的模型稍微有点区别，全局队列和本地队列是隔离的，也就是说本地队列不会去全局队列中取任务。</p>
<p>####　2.Processor执行器
Processor执行器是协程的载体，对协程来说Processor就是逻辑的CPU。Processor中有协程执行的上下文信息，还有绑定的线程信息。先看下BindContext的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Processor::BindContext</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ProcessorContext</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 协程执行的上下文信息，会随着协程切换而切换</span>
<span class="w">  </span><span class="n">context_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 2. 绑定Processor到具体的线程</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">thread_flag_</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">thread_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Processor</span><span class="o">::</span><span class="n">Run</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>也就是说协程运行在Processor之上，切换协程的时候传入对应的上下文到Processor，然后Processor开始执行协程任务。下面看Processor是如何执行的。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Processor::Run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 获取线程的PID，系统内唯一</span>
<span class="w">  </span><span class="n">tid_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">syscall</span><span class="p">(</span><span class="n">SYS_gettid</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="n">snap_shot_</span><span class="o">-&gt;</span><span class="n">processor_id</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">tid_</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_likely</span><span class="p">(</span><span class="n">running_</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_likely</span><span class="p">(</span><span class="n">context_</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 2. 获取优先级最高并且准备就绪的协程</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">croutine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context_</span><span class="o">-&gt;</span><span class="n">NextRoutine</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">croutine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">snap_shot_</span><span class="o">-&gt;</span><span class="n">execute_start_time</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">cyber</span><span class="o">::</span><span class="n">Time</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">ToNanosecond</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">snap_shot_</span><span class="o">-&gt;</span><span class="n">routine_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">croutine</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 3. 执行协程任务，完成后释放协程</span>
<span class="w">        </span><span class="n">croutine</span><span class="o">-&gt;</span><span class="n">Resume</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">croutine</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">snap_shot_</span><span class="o">-&gt;</span><span class="n">execute_start_time</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 4. 如果协程组中没有空闲的协程，则等待</span>
<span class="w">        </span><span class="n">context_</span><span class="o">-&gt;</span><span class="n">Wait</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 5. 如果上下文为空，则线程阻塞10毫秒</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="n">mtx_ctx_</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">cv_ctx_</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>疑问</strong>：</p>
<ol class="arabic simple">
<li><p>因为Processor每次都会从高优先级的队列开始取任务，假设Processor的数量不够，可能会出现低优先级的协程永远得不到调度的情况。</p></li>
<li><p>协程的调度没有抢占，也就是说一个协程在执行的过程中，除非主动让出，否则会一直占用Processor，如果Processor在执行低优先级的任务，来了一个高优先级的任务并不能抢占执行。调度器的抢占还是交给线程模型去实现了，cyber中通过调节cgroup来调节，保证优先级高的任务优先执行。</p></li>
</ol>
<p>一共有2种ProcessorContext上下文”ClassicContext”和”ChoreographyContext”上下文，分别对应不同的调度策略。后面分析Scheduler对象的时候，我们会接着分析。</p>
</div>
<div class="section" id="conf">
<h3>3. conf配置文件<a class="headerlink" href="#conf" title="Permalink to this headline"></a></h3>
<p>Scheduler调度的配置文件在”conf”目录中，配置文件中可以设置线程线程的CPU亲和性以及调度测量，也可以设置cgroup，还可以设置协程的优先级。下面以”example_sched_classic.conf”文件来举例子。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>scheduler_conf {
    // 1. 设置调度器策略
    policy: &quot;classic&quot;
    // 2. 设置cpu set
    process_level_cpuset: &quot;0-7,16-23&quot; # all threads in the process are on the cpuset
    // 3. 设置线程的cpuset，调度策略和优先级
    threads: [
        {
            name: &quot;async_log&quot;
            cpuset: &quot;1&quot;
            policy: &quot;SCHED_OTHER&quot;   # policy: SCHED_OTHER,SCHED_RR,SCHED_FIFO
            prio: 0
        }, {
            name: &quot;shm&quot;
            cpuset: &quot;2&quot;
            policy: &quot;SCHED_FIFO&quot;
            prio: 10
        }
    ]
    classic_conf {
        // 4. 设置分组，线程组的cpuset，cpu亲和性，调度测量和优先级。设置调度器创建&quot;processor&quot;对象的个数，以及协程的优先级。  
        groups: [
            {
                name: &quot;group1&quot;
                processor_num: 16
                affinity: &quot;range&quot;
                cpuset: &quot;0-7,16-23&quot;
                processor_policy: &quot;SCHED_OTHER&quot;  # policy: SCHED_OTHER,SCHED_RR,SCHED_FIFO
                processor_prio: 0
                tasks: [
                    {
                        name: &quot;E&quot;
                        prio: 0
                    }
                ]
            },{
                name: &quot;group2&quot;
                processor_num: 16
                affinity: &quot;1to1&quot;
                cpuset: &quot;8-15,24-31&quot;
                processor_policy: &quot;SCHED_OTHER&quot;
                processor_prio: 0
                tasks: [
                    {
                        name: &quot;A&quot;
                        prio: 0
                    },{
                        name: &quot;B&quot;
                        prio: 1
                    },{
                        name: &quot;C&quot;
                        prio: 2
                    },{
                        name: &quot;D&quot;
                        prio: 3
                    }
                ]
            }
        ]
    }
}
</pre></div>
</div>
<p>下面我们开始看调度器，上述已经简单的介绍了2种调度器，SchedulerClassic是基于全局优先队列的调度器。</p>
</div>
<div class="section" id="schedulerclassic">
<h3>SchedulerClassic对象<a class="headerlink" href="#schedulerclassic" title="Permalink to this headline"></a></h3>
<p>我们知道协程实际上建立在线程之上，线程分时执行多个协程，看上去多个协程就是一起工作的。假如让你设计一个协程池，首先需要设置协程池中协程的个数，当协程超过协程池个数的时候需要把协程放入一个阻塞队列中，如果队列满了，还有协程到来，那么丢弃到来的协程，并且报错。（上述设计借鉴了线程池的思路）</p>
</div>
<div class="section" id="processor">
<h3>创建Processor<a class="headerlink" href="#processor" title="Permalink to this headline"></a></h3>
<p>调度器中首先会创建Processor，并且绑定到线程。调度器根据”conf”目录中的cgroup配置初始化线程，根据”processor_num”的个数创建多个Processor，并且绑定到线程。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">SchedulerClassic::CreateProcessor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//  读取调度配置文件，参照conf目录</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">classic_conf_</span><span class="p">.</span><span class="n">groups</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 1. 分组名称 </span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">.</span><span class="n">name</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 2. 分组执行器(线程)数量 等于协程池大小</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">proc_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">.</span><span class="n">processor_num</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">task_pool_size_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">task_pool_size_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc_num</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 3. 分组CPU亲和性</span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">affinity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">.</span><span class="n">affinity</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 4. 分组线程调度策略</span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">processor_policy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">.</span><span class="n">processor_policy</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 5. 分组优先级</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">processor_prio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">.</span><span class="n">processor_prio</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 7. 分组cpu set</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cpuset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ParseCpuset</span><span class="p">(</span><span class="n">group</span><span class="p">.</span><span class="n">cpuset</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuset</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">proc_num</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ClassicContext</span><span class="o">&gt;</span><span class="p">(</span><span class="n">group_name</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">pctxs_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 8. 绑定上下文</span>
<span class="w">      </span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">BindContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 9. 设置线程的cpuset和cpu亲和性</span>
<span class="w">      </span><span class="n">SetSchedAffinity</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">Thread</span><span class="p">(),</span><span class="w"> </span><span class="n">cpuset</span><span class="p">,</span><span class="w"> </span><span class="n">affinity</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 10. 设置线程调度策略和优先级 (proc-&gt;Tid()为线程pid)</span>
<span class="w">      </span><span class="n">SetSchedPolicy</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">Thread</span><span class="p">(),</span><span class="w"> </span><span class="n">processor_policy</span><span class="p">,</span><span class="w"> </span><span class="n">processor_prio</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">Tid</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">processors_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>SchedulerClassic是Scheduler的子类，Scheduler中实现了”CreateTask”和”NotifyTask”接口，用于创建任务和唤醒任务。对用户来说只需要关心任务，Scheduler为我们屏蔽了Processor对象的操作。对应的子类中实现了”DispatchTask”，”RemoveTask”和”NotifyProcessor”的操作。<br />
我们先看Scheduler如何创建任务。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool Scheduler::CreateTask(std::function&lt;void()&gt;&amp;&amp; func,
                           const std::string&amp; name,
                           std::shared_ptr&lt;DataVisitorBase&gt; visitor) {

  auto task_id = GlobalData::RegisterTaskName(name);
  // 1. 创建协程，绑定func函数
  auto cr = std::make_shared&lt;CRoutine&gt;(func);
  cr-&gt;set_id(task_id);
  cr-&gt;set_name(name);
  AINFO &lt;&lt; &quot;create croutine: &quot; &lt;&lt; name;
  
  // 2. 分发任务
  if (!DispatchTask(cr)) {
    return false;
  }

  // 3. 注册回调，visitor参数为可选的。
  if (visitor != nullptr) {
    visitor-&gt;RegisterNotifyCallback([this, task_id]() {
      if (cyber_unlikely(stop_.load())) {
        return;
      }
      this-&gt;NotifyProcessor(task_id);
    });
  }
  return true;
}
</pre></div>
</div>
<p>总结：</p>
<ol class="arabic simple">
<li><p>创建任务的时候只有对应数据访问的DataVisitorBase注册了回调，其它的任务要自己触发回调。</p></li>
<li><p>DispatchTask中调用子类中的不同策略进行任务分发。</p></li>
</ol>
<p>接着我们看SchedulerClassic的DispatchTask调度策略。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">SchedulerClassic::DispatchTask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CRoutine</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">cr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 根据协程id，获取协程的锁</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. 将协程放入协程map</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">WriteLockGuard</span><span class="o">&lt;</span><span class="n">AtomicRWLock</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="n">id_cr_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id_cr_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">id_cr_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">id_cr_</span><span class="p">[</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 3. 设置协程的优先级和group</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cr_confs_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cr_confs_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ClassicTask</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cr_confs_</span><span class="p">[</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()];</span><span class="w"></span>
<span class="w">    </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_priority</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">prio</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_group_name</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">group_name</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// croutine that not exist in conf</span>
<span class="w">    </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_group_name</span><span class="p">(</span><span class="n">classic_conf_</span><span class="p">.</span><span class="n">groups</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">name</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 4. 将协程放入对应的优先级队列</span>
<span class="w">  </span><span class="c1">// Enqueue task.</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">WriteLockGuard</span><span class="o">&lt;</span><span class="n">AtomicRWLock</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">ClassicContext</span><span class="o">::</span><span class="n">rq_locks_</span><span class="p">[</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">group_name</span><span class="p">()].</span><span class="n">at</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">()));</span><span class="w"></span>
<span class="w">    </span><span class="n">ClassicContext</span><span class="o">::</span><span class="n">cr_group_</span><span class="p">[</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">group_name</span><span class="p">()]</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">cr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 5. 唤醒协程组</span>
<span class="w">  </span><span class="n">ClassicContext</span><span class="o">::</span><span class="n">Notify</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">group_name</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这里NotifyProcessor实际上就是唤醒对应Processor的上下文执行环境。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">SchedulerClassic::NotifyProcessor</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">crid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_unlikely</span><span class="p">(</span><span class="n">stop_</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ReadLockGuard</span><span class="o">&lt;</span><span class="n">AtomicRWLock</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="n">id_cr_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id_cr_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">crid</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">id_cr_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">cr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id_cr_</span><span class="p">[</span><span class="n">crid</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RoutineState</span><span class="o">::</span><span class="n">DATA_WAIT</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">          </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RoutineState</span><span class="o">::</span><span class="n">IO_WAIT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">SetUpdateFlag</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">ClassicContext</span><span class="o">::</span><span class="n">Notify</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">group_name</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>疑问:</p>
<ol class="arabic simple">
<li><p>如果协程在等待IO，系统知道协程在等待io，但还是触发对应的协程组去工作。并没有让协程继续阻塞？？？</p></li>
</ol>
<p>再看如何从”ClassicContext”获取Processor执行的协程。下图是全局协程队列的数据结构，为一个2级数组，第一级数组为优先级数组，第二级数组为一个队列。<br />
<img alt="scheduler_data" src="../../_images/scheduler_data.jpg" /></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CRoutine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ClassicContext</span><span class="o">::</span><span class="n">NextRoutine</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_unlikely</span><span class="p">(</span><span class="n">stop_</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 1. 从优先级最高的队列开始遍历</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_PRIO</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 2. 获取当前优先级队列的锁</span>
<span class="w">    </span><span class="n">ReadLockGuard</span><span class="o">&lt;</span><span class="n">AtomicRWLock</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="n">lq_</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">multi_pri_rq_</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">Acquire</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 3. 返回状态就绪的协程</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">UpdateState</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RoutineState</span><span class="o">::</span><span class="n">READY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">cr</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>我们知道线程阻塞的条件有4种：</p>
<ol class="arabic simple">
<li><p>通过调用sleep(millseconds)使任务进入休眠状态</p></li>
<li><p>通过调用wait（）使线程挂起</p></li>
<li><p>等待某个输入、输出流</p></li>
<li><p>等待锁</p></li>
</ol>
<p>而Processor绑定的线程阻塞是通过上下文的等待实现的。在ClassicContext中等待条件（1s的超时时间），等待的时候设置notify_grp_减1。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">ClassicContext</span><span class="p">::</span><span class="n">Wait</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="mf">1.</span> <span class="n">获取锁</span>
  <span class="n">std</span><span class="p">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mtx_wrapper_</span><span class="o">-&gt;</span><span class="n">Mutex</span><span class="p">());</span>
  <span class="o">//</span> <span class="mf">2.</span> <span class="n">等待条件大于0</span>
  <span class="n">cw_</span><span class="o">-&gt;</span><span class="n">Cv</span><span class="p">()</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">chrono</span><span class="p">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
                     <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">notify_grp_</span><span class="p">[</span><span class="n">current_grp</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
  <span class="o">//</span> <span class="mf">3.</span> <span class="n">对应协程组的唤醒条件减1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">notify_grp_</span><span class="p">[</span><span class="n">current_grp</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">notify_grp_</span><span class="p">[</span><span class="n">current_grp</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Processor的唤醒也是通过上下文实现的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">ClassicContext</span><span class="p">::</span><span class="n">Notify</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">group_name</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="mf">1.</span> <span class="n">加锁</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">mtx_wq_</span><span class="p">[</span><span class="n">group_name</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">Mutex</span><span class="p">()</span><span class="o">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="o">//</span> <span class="mf">2.</span> <span class="n">协程唤醒条件加1</span>
  <span class="n">notify_grp_</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">mtx_wq_</span><span class="p">[</span><span class="n">group_name</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">Mutex</span><span class="p">()</span><span class="o">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="o">//</span> <span class="mf">3.</span> <span class="n">唤醒线程</span>
  <span class="n">cv_wq_</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">Cv</span><span class="p">()</span><span class="o">.</span><span class="n">notify_one</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>关于SchedulerClassic我们就先介绍到这里，下面我们开始介绍另外一种调度器SchedulerChoreography。</p>
</div>
<div class="section" id="id20">
<h3>SchedulerClassic调度器<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h3>
<p>SchedulerChoreography创建Processor，会分2部分创建，一部分是有本地队列的Processor，一部分是协程池的Processor。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SchedulerChoreography</span><span class="p">::</span><span class="n">CreateProcessor</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">proc_num_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="o">//</span> <span class="mf">1.</span> <span class="n">绑定ChoreographyContext</span>
    <span class="n">auto</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ChoreographyContext</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">BindContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="n">SetSchedAffinity</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">Thread</span><span class="p">(),</span> <span class="n">choreography_cpuset_</span><span class="p">,</span>
                     <span class="n">choreography_affinity_</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">SetSchedPolicy</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">Thread</span><span class="p">(),</span> <span class="n">choreography_processor_policy_</span><span class="p">,</span>
                   <span class="n">choreography_processor_prio_</span><span class="p">,</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">Tid</span><span class="p">());</span>
    <span class="n">pctxs_</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="n">processors_</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">task_pool_size_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="o">//</span> <span class="mf">2.</span> <span class="n">绑定ClassicContext</span>
    <span class="n">auto</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ClassicContext</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">BindContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="n">SetSchedAffinity</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">Thread</span><span class="p">(),</span> <span class="n">pool_cpuset_</span><span class="p">,</span> <span class="n">pool_affinity_</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">SetSchedPolicy</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">Thread</span><span class="p">(),</span> <span class="n">pool_processor_policy_</span><span class="p">,</span> <span class="n">pool_processor_prio_</span><span class="p">,</span>
                   <span class="n">proc</span><span class="o">-&gt;</span><span class="n">Tid</span><span class="p">());</span>
    <span class="n">pctxs_</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="n">processors_</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在看SchedulerChoreography如何分发任务。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">SchedulerChoreography::DispatchTask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CRoutine</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">cr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1. 根据协程id，获取协程的锁</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. 设置优先级和协程绑定的Processor Id</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cr_confs_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cr_confs_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ChoreographyTask</span><span class="w"> </span><span class="n">taskconf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cr_confs_</span><span class="p">[</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()];</span><span class="w"></span>
<span class="w">    </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_priority</span><span class="p">(</span><span class="n">taskconf</span><span class="p">.</span><span class="n">prio</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">taskconf</span><span class="p">.</span><span class="n">has_processor</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_processor_id</span><span class="p">(</span><span class="n">taskconf</span><span class="p">.</span><span class="n">processor</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">processor_id</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 3. 如果Processor Id小于proc_num_，默认Processor Id为-1</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">proc_num_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 4. 协程放入上下文本地队列中</span>
<span class="w">    </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ChoreographyContext</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pctxs_</span><span class="p">[</span><span class="n">pid</span><span class="p">].</span><span class="n">get</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">cr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">set_group_name</span><span class="p">(</span><span class="n">DEFAULT_GROUP_NAME</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 5. 协程放入ClassicContext协程池队列中</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WriteLockGuard</span><span class="o">&lt;</span><span class="n">AtomicRWLock</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">ClassicContext</span><span class="o">::</span><span class="n">rq_locks_</span><span class="p">[</span><span class="n">DEFAULT_GROUP_NAME</span><span class="p">].</span><span class="n">at</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">()));</span><span class="w"></span>
<span class="w">      </span><span class="n">ClassicContext</span><span class="o">::</span><span class="n">cr_group_</span><span class="p">[</span><span class="n">DEFAULT_GROUP_NAME</span><span class="p">]</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">cr</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">cr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>疑问：</p>
<ol class="arabic simple">
<li><p>cr-&gt;processor_id()的默认值为”-1”，而vector访问越界的时候不会报错，本来应该放入全局队列中的？？？</p></li>
</ol>
</div>
<div class="section" id="choreographycontext">
<h3>ChoreographyContext上下文<a class="headerlink" href="#choreographycontext" title="Permalink to this headline"></a></h3>
<p>ChoreographyContext中的调度就非常简单了。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>std::shared_ptr&lt;CRoutine&gt; ChoreographyContext::NextRoutine() {
  // 1. 从本地队列中取出协程
  ReadLockGuard&lt;AtomicRWLock&gt; lock(rq_lk_);
  for (auto it : cr_queue_) {
    auto cr = it.second;
    if (!cr-&gt;Acquire()) {
      continue;
    }

    if (cr-&gt;UpdateState() == RoutineState::READY) {
      return cr;
    }
    cr-&gt;Release();
  }
  return nullptr;
}
</pre></div>
</div>
<p>ChoreographyContext中”Wait”和”Notify”方法与ClassicContext类似，这里就不展开了。</p>
</div>
<div class="section" id="id21">
<h3>总结<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h3>
<ol class="arabic simple">
<li><p>SchedulerClassic 采用了协程池的概念，协程没有绑定到具体的Processor，所有的协程放在全局的优先级队列中，每次从最高优先级的任务开始执行。</p></li>
<li><p>SchedulerChoreography 采用了本地队列和全局队列相结合的方式，通过”ChoreographyContext”运行本地队列的线程，通过”ClassicContext”来运行全局队列。</p></li>
<li><p>Processor对协程来说是一个逻辑上的cpu，ProcessorContext实现Processor的运行上下文，通过ProcessorContext来获取协程，休眠或者唤醒，Scheduler调度器实现了协程调度算法。</p></li>
</ol>
<p>下面介绍下cyber的异步调用接口”cyber::Async”，启动异步执行任务。</p>
</div>
</div>
<div class="section" id="id22">
<h2>异步调用<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2>
<p>在”task.h”中定义了异步调用的方法包括”Async”,”Yield”,”SleepFor”,”USleep”方法。下面我们逐个看下上述方法的实现。</p>
<div class="section" id="async">
<h3>Async方法<a class="headerlink" href="#async" title="Permalink to this headline"></a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">Async</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">GlobalData</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IsRealityMode</span><span class="p">()</span><span class="w"></span>
<span class="w">             </span><span class="o">?</span><span class="w"> </span><span class="n">TaskManager</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="w"></span>
<span class="w">                                                </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span><span class="w"></span>
<span class="w">             </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="w"></span>
<span class="w">                   </span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果为真实模式，则采用”TaskManager”的方法生成协程任务，如果是仿真模式则创建线程。</p>
<p>TaskManager实际上实现了一个任务池，最大执行的任务数为scheduler模块中设置的TaskPoolSize大小。超出的任务会放在大小为1000的有界队列中，如果超出1000，任务会被丢弃。下面我们看TaskManager的具体实现。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>TaskManager::TaskManager()
// 1. 设置有界队列，长度为1000
    : task_queue_size_(1000),
      task_queue_(new base::BoundedQueue&lt;std::function&lt;void()&gt;&gt;()) {
  if (!task_queue_-&gt;Init(task_queue_size_, new base::BlockWaitStrategy())) {
    AERROR &lt;&lt; &quot;Task queue init failed&quot;;
    throw std::runtime_error(&quot;Task queue init failed&quot;);
  }
  // 2. 协程任务，每次从队列中取任务执行，如果没有任务则让出协程，等待数据
  auto func = [this]() {
    while (!stop_) {
      std::function&lt;void()&gt; task;
      if (!task_queue_-&gt;Dequeue(&amp;task)) {
        auto routine = croutine::CRoutine::GetCurrentRoutine();
        routine-&gt;HangUp();
        continue;
      }
      task();
    }
  };

  num_threads_ = scheduler::Instance()-&gt;TaskPoolSize();
  auto factory = croutine::CreateRoutineFactory(std::move(func));
  tasks_.reserve(num_threads_);
  // 3. 创建TaskPoolSize个任务并且放入调度器
  for (uint32_t i = 0; i &lt; num_threads_; i++) {
    auto task_name = task_prefix + std::to_string(i);
    tasks_.push_back(common::GlobalData::RegisterTaskName(task_name));
    if (!scheduler::Instance()-&gt;CreateTask(factory, task_name)) {
      AERROR &lt;&lt; &quot;CreateTask failed:&quot; &lt;&lt; task_name;
    }
  }
}
</pre></div>
</div>
<ol class="arabic simple">
<li><p>协程承载运行具体的任务，也就是说如果任务队列中有任务，则调用协程去执行，如果队列中没有任务，则让出协程，并且设置协程为等待数据的状态，那么让出协程之后唤醒是谁去触发的呢？<br />
每次在任务队列中添加任务的时候，会唤醒协程执行任务。</p></li>
<li><p>task_queue_会被多个协程访问，并发数据访问这里没有加锁，需要看下这个队列是如何实现的？？？</p></li>
<li><p>上述的任务可以在”conf”文件中设置”/internal/task + index”的优先级来实现。</p></li>
</ol>
<p>接着看下Enqueue的实现，加入任务到任务队列。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">Enqueue</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 1. 返回值为future类型</span>
<span class="w">      </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">return_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">stop_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 2. 将函数加入任务队列，注意这里的任务不是调度单元里的任务，可以理解为一个函数</span>
<span class="w">      </span><span class="n">task_queue_</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">([</span><span class="n">task</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">task</span><span class="p">)();</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 3. 这里的任务是调度任务，唤醒每个协程执行任务。</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tasks_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">scheduler</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NotifyTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">return_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">get_future</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>每次在任务队列中添加任务的时候，唤醒任务协程中所有的协程。</p>
</div>
<div class="section" id="yieldsleep">
<h3>Yield和Sleep方法<a class="headerlink" href="#yieldsleep" title="Permalink to this headline"></a></h3>
<p>Yield方法和Async类似，如果为协程则让出当前协程，如果为线程则让出线程。SleepFor和USleep方法类似，这里就不展开了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Yield</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">croutine</span><span class="o">::</span><span class="n">CRoutine</span><span class="o">::</span><span class="n">GetCurrentRoutine</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">croutine</span><span class="o">::</span><span class="n">CRoutine</span><span class="o">::</span><span class="n">Yield</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sysmo">
<h2>SysMo系统监控<a class="headerlink" href="#sysmo" title="Permalink to this headline"></a></h2>
<p>SysMo模块的用途主要是监控系统协程的运行状况。</p>
<div class="section" id="start">
<h3>Start<a class="headerlink" href="#start" title="Permalink to this headline"></a></h3>
<p>在start中单独启动一个线程去进行系统监控，这里没有设置线程的优先级，因此不能在”conf”文件中设置优先级？？？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">SysMo::Start</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">sysmo_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetEnv</span><span class="p">(</span><span class="s">&quot;sysmo_start&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sysmo_start</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">sysmo_start</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">start_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">sysmo_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SysMo</span><span class="o">::</span><span class="n">Checker</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="checker">
<h3>Checker<a class="headerlink" href="#checker" title="Permalink to this headline"></a></h3>
<p>每隔100ms调用一次Checker，获取调度信息。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">SysMo::Checker</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cyber_unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">shut_down_</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">scheduler</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">CheckSchedStatus</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="n">lk_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cv_</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">sysmo_interval_ms_</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>打印的是协程的调度快照。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Scheduler::CheckSchedStatus</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">snap_info</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Time</span><span class="o">::</span><span class="n">Now</span><span class="p">().</span><span class="n">ToNanosecond</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">processor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">processors_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">snap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">ProcSnapshot</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">execute_start_time</span><span class="p">.</span><span class="n">load</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">execute_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">execute_start_time</span><span class="p">.</span><span class="n">load</span><span class="p">())</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">snap_info</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">processor_id</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">routine_name</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">execute_time</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">snap_info</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">snap</span><span class="o">-&gt;</span><span class="n">processor_id</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span><span class="w"></span>
<span class="w">          </span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;:idle&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">snap_info</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">snap_info</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;timestamp: &quot;</span><span class="p">).</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">now</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">snap_info</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">snap_info</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="timer">
<h2>Timer定时器<a class="headerlink" href="#timer" title="Permalink to this headline"></a></h2>
<p>定时器提供在指定的时间触发执行的功能。定时器的应用非常普遍，比如定时触发秒杀活动、定时清理日志、定时发送心跳信息等。实现定时器的方法多种多样，古代有采用水漏或者沙漏的方式，近代有采用机械的方式（各种各样的时钟），数字脉冲，元素衰减等方式。<br />
在计算机领域有2种形式，<strong>一种是硬件定时器，一种是软件定时器</strong>。硬件定时器的原理是计算时钟脉冲，当规定的时钟脉冲之后由硬件触发中断程序执行，硬件定时器一般是芯片自带的，硬件定时器时间比较精准但是数量有限，因此人们又发明了软件定时器。软件定时器由软件统计计算机时钟个数，然后触发对应的任务执行，由于是纯软件实现，理论上可以创建很多个，下面我们主要看下软件定时器的实现。</p>
</div>
<div class="section" id="id23">
<h2>定时器的实现<a class="headerlink" href="#id23" title="Permalink to this headline"></a></h2>
<div class="section" id="id24">
<h3>双向链表<a class="headerlink" href="#id24" title="Permalink to this headline"></a></h3>
<p>首先我们想到的是把定时任务放入一个队列中，每隔固定的时间（一个tick）去检查队列中是否有超时的任务，如果有，则触发执行该任务。这样做的好处是实现简单，但是每次都需要轮询整个队列来找到谁需要被触发，当队列的长度很大时，每个固定时间都需要去轮询一次队列，时间开销比较大。当我们需要删除一个任务的时候，也需要轮询一遍队列找到需要删除的任务，实际上我们可以优化一下用双向链表去实现队列，这样删除的任务的时间复杂度就是O(1)了。总结一下就是采用双向链表实现队列，插入的时间复杂度是O(1)，删除的时间复杂度也是O(1)，但是查询的时间复杂度是O(n)。<br />
<img alt="linklist" src="../../_images/linklist.jpg" /></p>
</div>
<div class="section" id="id25">
<h3>最小堆<a class="headerlink" href="#id25" title="Permalink to this headline"></a></h3>
<p>最小堆的实现方式是为了解决上述查找的时候需要遍历整个链表的问题，我们知道最小堆中堆顶的元素就是最小的元素，每次我们只需要检查堆顶的元素是否超时，超时则弹出执行，然后再检查新的堆顶元素是否超时，这样查找可执行任务的时间复杂度约等于O(1)，最小堆虽然提高了查找的时间，但是插入和删除任务的时间复杂度为O(log2n)。下面我们看一个例子。<br />
堆中节点的值存放的是任务到期的时间，每隔1分钟判断下是否有任务需要执行，比如任务A是19:01分触发，周期为5分钟，任务B是19:02分触发，周期为10分钟，那么第一次最小堆弹出19:01，执行之后，在堆中重新插入19:06分的任务A，这时候任务B到了堆顶，1分钟之后检测需要执行任务B，执行完成后，在堆中重新插入19:12分的任务B。然后循环执行上述过程。每执行一次任务都需要重新插入任务到堆中，当任务频繁执行的时候，插入任务的开销也不容忽略。<br />
<img alt="heap" src="../../_images/heap.jpg" /></p>
</div>
<div class="section" id="id26">
<h3>时间轮<a class="headerlink" href="#id26" title="Permalink to this headline"></a></h3>
<p>最后，我们介绍一种插入、删除和触发执行都是O(1)的方法，由计算机科学家”George Varghese”等提出，在NetBSD(一种操作系统)上实现并替代了早期内核中的callout定时器实现。最原始的时间轮如下图。
<img alt="timing_wheel" src="../../_images/timing_wheel.jpg" /><br />
一共有8个bucket，每个bucket代表tick的时间，类似于时钟，每个1秒钟走一格，我们可以定义tick的时间为1秒钟，那么bucket[1]就代表第1秒，而bucket[8]就代表第8秒，然后循环进行上述步骤。一个bucket中可能有多个任务，每个任务采用链表的方式连接起来。下面通过一个例子来说明如何添加、删除和查找任务。<br />
假设时间轮中有8个bucket，每个bucket占用一个tick时间，每个tick为1秒。当前有2个定时任务A、B，分别需要3秒、11秒执行一次。目前指针指在0的位置，3秒钟之后指针将指向bucket[3]的位置，因此我们把任务A放入bucket[3]中，接下来我们再看如何放置任务B，任务B是11秒之后执行，也就是说时间轮转1圈之后，再过3秒种，任务B才执行，那么如何标记任务的圈数呢？这里引入了round的概念，round为1就表示需要1圈，如果round为2则需要2圈，同理推广到其它圈数。我们把B任务也放入bucket[3]，但是设置它的round为1。
我们先看下任务A和任务B的执行过程，3秒钟之后时间轮转到bucket[3]，这时候检查bucket[3]中的任务，只执行round为0的任务，这里执行任务A，然后把bucket[3]中所有任务的round减1，这时候任务B的round数为0了，等到时间轮转一圈之后，就会执行任务B了。<br />
这里还有一个疑问就是任务A执行完成之后，下一次触发如何执行，其实在bucket[3]执行完成之后，会把任务A从bucket[3]中删除，然后从新计算3+3，放入bucket[6]中，等到bucket[6]执行完成之后，然后再放入（6+3）对8取余，放入bucket[1]中。也就是说每次任务执行完成之后需要重新计算任务在哪个bucket，然后放入对应的bucket中。<br />
<img alt="timing_wheel_progress" src="../../_images/timing_wheel_progress.jpg" /><br />
可以看到时间轮算法的插入复杂度是O(1)，删除的复杂度也是O(1)，查找执行的复杂度也是O(1)，因此时间轮实现的定时器非常高效。</p>
</div>
</div>
<div class="section" id="id27">
<h2>Cyber定时器实现<a class="headerlink" href="#id27" title="Permalink to this headline"></a></h2>
<div class="section" id="id28">
<h3>用户接口<a class="headerlink" href="#id28" title="Permalink to this headline"></a></h3>
<p>Timer对象是开放给用户的接口，主要实现了定时器的配置”TimerOption”，启动定时器和关闭定时器3个接口。我们首先看下定时器的配置。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">TimerOption</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">period</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">oneshot</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">period</span><span class="p">(</span><span class="n">period</span><span class="p">),</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="n">callback</span><span class="p">),</span><span class="w"> </span><span class="n">oneshot</span><span class="p">(</span><span class="n">oneshot</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>包括：定时器周期、回调函数、一次触发还是周期触发（默认为周期触发）。</p>
<p>Timer对象主要的实现都在”Start()”中。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Timer::Start</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 1. 首先判断定时器是否已经启动</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">started_</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="nb">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 2. 初始化任务</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">InitTimerTask</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 3. 在时间轮中增加任务</span>
<span class="w">      </span><span class="n">timing_wheel_</span><span class="o">-&gt;</span><span class="n">AddTask</span><span class="p">(</span><span class="n">task_</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">AINFO</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;start timer [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">task_</span><span class="o">-&gt;</span><span class="n">timer_id_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Start中的步骤很简单:</p>
<ol class="arabic simple">
<li><p>判断定时器是否已经启动</p></li>
<li><p>如果定时器没有启动，则初始化定时任务</p></li>
<li><p>在时间轮中增加任务。</p></li>
</ol>
<p>那么初始化任务中做了哪些事情呢？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">Timer::InitTimerTask</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 1. 初始化定时任务</span>
<span class="w">  </span><span class="n">task_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">TimerTask</span><span class="p">(</span><span class="n">timer_id_</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">task_</span><span class="o">-&gt;</span><span class="n">interval_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timer_opt_</span><span class="p">.</span><span class="n">period</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">task_</span><span class="o">-&gt;</span><span class="n">next_fire_duration_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_</span><span class="o">-&gt;</span><span class="n">interval_ms</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 2. 是否单次触发</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer_opt_</span><span class="p">.</span><span class="n">oneshot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">TimerTask</span><span class="o">&gt;</span><span class="w"> </span><span class="n">task_weak_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 3. 注册任务回调</span>
<span class="w">    </span><span class="n">task_</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timer_opt_</span><span class="p">.</span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">task_weak_ptr</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lg</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">callback</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">TimerTask</span><span class="o">&gt;</span><span class="w"> </span><span class="n">task_weak_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 注册任务回调</span>
<span class="w">    </span><span class="n">task_</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timer_opt_</span><span class="p">.</span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">task_weak_ptr</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lg</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Time</span><span class="o">::</span><span class="n">MonoTime</span><span class="p">().</span><span class="n">ToNanosecond</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">callback</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Time</span><span class="o">::</span><span class="n">MonoTime</span><span class="p">().</span><span class="n">ToNanosecond</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">execute_time_ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">last_execute_time_ns</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">last_execute_time_ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// start - task-&gt;last_execute_time_ns 为2次执行真实间隔时间，task-&gt;interval_ms是设定的间隔时间</span>
<span class="w">        </span><span class="c1">// 注意误差会修复补偿，因此这里用的是累计，2次误差会抵消，保持绝对误差为0</span>
<span class="w">        </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">accumulated_error_ns</span><span class="w"> </span><span class="o">+=</span><span class="w"></span>
<span class="w">            </span><span class="n">start</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">last_execute_time_ns</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">interval_ms</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">last_execute_time_ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 如果执行时间大于任务周期时间，则下一个tick马上执行</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">execute_time_ms</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">interval_ms</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">next_fire_duration_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TIMER_RESOLUTION_MS</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">accumulated_error_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">::</span><span class="n">llround</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">accumulated_error_ns</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">1e6</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">interval_ms</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">execute_time_ms</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                                 </span><span class="n">TIMER_RESOLUTION_MS</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">accumulated_error_ms</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// 这里会补偿误差</span>
<span class="w">          </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">next_fire_duration_ms</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">interval_ms</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">execute_time_ms</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">accumulated_error_ms</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">next_fire_duration_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TIMER_RESOLUTION_MS</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">TimingWheel</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>下面对Timer中初始化任务的过程做一些解释。</p>
<ol class="arabic simple">
<li><p>在Timer对象中创建Task任务并注册回调”task_-&gt;callback”，任务回调中首先会调用用户传入的”callback()”函数，然后把新的任务放入下一个时间轮bucket中，对应到代码就是”TimingWheel::Instance()-&gt;AddTask(task)”。</p></li>
<li><p>task-&gt;next_fire_duration_ms是任务下一次执行的间隔，这个间隔是以task执行完成之后为起始时间的，因为每次插入新任务到时间轮都是在用户”callback”函数执行之后进行的，因此这里的时间起点也是以这个时间为准。</p></li>
<li><p>task-&gt;accumulated_error_ns是累计时间误差，注意这个误差是累计的，而且每次插入任务的时候都会修复这个误差，因此这个误差不会一直增大，也就是说假设你第一次执行的比较早，那么累计误差为负值，下次执行的时间间隔就会变长，如果第一次执行的时间比较晚，那么累计误差为正值，下次执行的时间间隔就会缩短。通过动态的调节，保持绝对的时间执行间隔一致。<br />
<img alt="timer_task" src="../../_images/timer_task.jpg" /></p></li>
</ol>
</div>
<div class="section" id="timingwheel">
<h3>TimingWheel时间轮<a class="headerlink" href="#timingwheel" title="Permalink to this headline"></a></h3>
<p>接下来看时间轮TimingWheel的实现，TimingWheel时间轮的配置如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">512</span><span class="n">个bucket</span>
<span class="mi">64</span><span class="n">个round</span>    
<span class="n">tick</span> <span class="n">为2ms</span>
</pre></div>
</div>
<p>TimingWheel是通过AddTask调用执行的，下面是具体过程。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">TimingWheel::AddTask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TimerTask</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">task</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">current_work_wheel_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 1.不是运行状态则启动时间轮</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">running_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 2.启动Tick线程，并且加入scheduler调度。</span>
<span class="w">    </span><span class="n">Start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 3. 计算一下轮bucket编号</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">work_wheel_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_work_wheel_index</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">                          </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">next_fire_duration_ms</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">TIMER_RESOLUTION_MS</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 4. 如果超过最大的bucket数</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">work_wheel_index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">WORK_WHEEL_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">real_work_wheel_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetWorkWheelIndex</span><span class="p">(</span><span class="n">work_wheel_index</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">remainder_interval_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real_work_wheel_index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">assistant_ticks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work_wheel_index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">WORK_WHEEL_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 5.疑问，如果转了一圈之后，为什么直接加入剩余的bucket？？？</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">assistant_ticks</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">        </span><span class="n">real_work_wheel_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">current_work_wheel_index_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">work_wheel_</span><span class="p">[</span><span class="n">real_work_wheel_index</span><span class="p">].</span><span class="n">AddTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;add task to work wheel. index :&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">real_work_wheel_index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">assistant_wheel_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 6.如果超出，则放入上一级时间轮中</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">current_assistant_wheel_index_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">assistant_wheel_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetAssistantWheelIndex</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">current_assistant_wheel_index_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">assistant_ticks</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">assistant_wheel_</span><span class="p">[</span><span class="n">assistant_wheel_index</span><span class="p">].</span><span class="n">AddTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;add task to assistant wheel. index : &quot;</span><span class="w"></span>
<span class="w">             </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">assistant_wheel_index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 7. 如果没有超过最大bucket数，则增加到对应的bucket中</span>
<span class="w">    </span><span class="n">work_wheel_</span><span class="p">[</span><span class="n">work_wheel_index</span><span class="p">].</span><span class="n">AddTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ADEBUG</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;add task [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">timer_id_</span><span class="w"></span>
<span class="w">           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;] to work wheel. index :&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">work_wheel_index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>从上述过程可以看出Cyber的时间轮单独采用一个线程调度执行”std::thread(<span class="xref myst">this</span> { this-&gt;TickFunc(); })”，定时任务则放入协程池中去执行。也就是说主线程单独执行时间计数，而具体的定时任务开多个协程去执行，可以并发执行多个定时任务。定时任务中最好不要引入阻塞的操作，或者执行时间过长。</p></li>
<li><p>Cyber定时器中引入了2级时间轮的方法（消息队列kafka中也是类似实现），类似时钟的小时指针和分钟指针，当一级时间轮触发完成之后，再移动到二级时间轮中执行。第二级时间轮不能超过一圈，因此定时器的最大定时时间为64<em>512</em>2ms，最大不超过约65s。
<img alt="timing_wheel_multi" src="../../_images/timing_wheel_multi.jpg" /></p></li>
</ol>
</div>
<div class="section" id="tick">
<h3>Tick<a class="headerlink" href="#tick" title="Permalink to this headline"></a></h3>
<p>接下来我们看下时间轮中的Tick是如何工作的。在上述”AddTask”中会调用”Start”函数启动一个线程，线程执行”TickFunc”。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">TimingWheel::TickFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Rate</span><span class="w"> </span><span class="n">rate</span><span class="p">(</span><span class="n">TIMER_RESOLUTION_MS</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000000</span><span class="p">);</span><span class="w">  </span><span class="c1">// ms to ns</span>
<span class="w">  </span><span class="c1">// 1. 循环调用</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">running_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 2. 执行bucket中的回调，并且删除当前bucket中的任务(回调中会增加新的任务到bucket)</span>
<span class="w">    </span><span class="n">Tick</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="n">tick_count_</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 3. 休眠一个Tick</span>
<span class="w">    </span><span class="n">rate</span><span class="p">.</span><span class="n">Sleep</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">current_work_wheel_index_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 4.获取当前bucket id，每次加1</span>
<span class="w">      </span><span class="n">current_work_wheel_index_</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">GetWorkWheelIndex</span><span class="p">(</span><span class="n">current_work_wheel_index_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 5.下一级时间轮已经转了一圈，上一级时间轮加1</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current_work_wheel_index_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 6.上一级时间轮bucket id加1</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">current_assistant_wheel_index_mutex_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">current_assistant_wheel_index_</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="n">GetAssistantWheelIndex</span><span class="p">(</span><span class="n">current_assistant_wheel_index_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 7. </span>
<span class="w">      </span><span class="n">Cascade</span><span class="p">(</span><span class="n">current_assistant_wheel_index_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这里需要注意假设二级时间轮中有一个任务的时间周期就为512，那么在当前bucket回调中又会在当前bucket中增加一个任务，那么这个任务会执行2次，如何解决这个问题呢？ Cyber中采用把这个任务放入上一级时间轮中，然后在触发一个周期之后，放到下一级的时间轮中触发。</p>
</div>
</div>
<div class="section" id="id29">
<h2>总结<a class="headerlink" href="#id29" title="Permalink to this headline"></a></h2>
<p>经过上述分析，介绍了Cyber中定时器的实现原理，这里还有2个疑问。</p>
<ol class="arabic simple">
<li><p>一是定时器是否为单线程，任务都是在单线程中的多个协程中执行？？？<br />
答：定时器的计数单独在一个线程中执行，具体的定时任务在协程池中执行，也就是说多个定时任务可以并发执行。</p></li>
<li><p>当”TimingWheel::AddTask”中”work_wheel_index &gt;= WORK_WHEEL_SIZE”并且”assistant_ticks == 1”时，假设原始的current_work_wheel_index_mutex_ = 200，消息触发周期为600个tick，那么按照上述计算方法得到的work_wheel_index = 800，real_work_wheel_index = 288，assistant_ticks = 1，那么”work_wheel_[real_work_wheel_index].AddTask(task)”会往288增加任务，实际上这个任务在88个tick之后就触发了？？？</p></li>
</ol>
</div>
<div class="section" id="data-fusion">
<h2>data_fusion_<a class="headerlink" href="#data-fusion" title="Permalink to this headline"></a></h2>
<p>data_fusion_总是以第一个消息为基准，查找融合最新的消息。</p>
</div>
<div class="section" id="transport">
<h2>Transport<a class="headerlink" href="#transport" title="Permalink to this headline"></a></h2>
<p>Transport 把消息通过 DataDispatcher 把消息放进buffer 并且触发 DataNotifier::Notify</p>
<p>notify之后会触发 协程执行 而协程会调用DataVisitor::TryFetch 去取数据</p>
<p>取到数据之后，调用process函数执行。</p>
</div>
<div class="section" id="listenerhandler-rtpsdispatcher">
<h2>ListenerHandler 和 RtpsDispatcher<a class="headerlink" href="#listenerhandler-rtpsdispatcher" title="Permalink to this headline"></a></h2>
<p>是否为通知signal接收发送消息，对应一张线性表？？？</p>
<p>RtpsDispatcher 用来分发消息，同时触发ListenerHandler？？？</p>
</div>
<div class="section" id="id30">
<h2>Croutine调度<a class="headerlink" href="#id30" title="Permalink to this headline"></a></h2>
<p>什么时候采用协程，用协程做了哪些工作？？？</p>
<div class="section" id="id31">
<h3>scheduler, task和croutine<a class="headerlink" href="#id31" title="Permalink to this headline"></a></h3>
<p>如果有一个新的任务需要处理，则调度器会创建一个任务，而任务又由协程去处理。
创建任务的时候DataVisitorBase在调度器中注册回调，这个回调触发调度器根据任务id进行NotifyProcessor</p>
<p>一个任务就是一个协程，协程负责调用reader enqueue读取消息，平时处于yeild状态，等到DataVisitor触发回调之后开始工作。</p>
</div>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline"></a></h2>
<p><a class="reference external" href="https://t.cj.sina.com.cn/articles/view/6080368657/16a6b101101900fpdw?sudaref=www.google.com&amp;display=0&amp;retcode=0">百度Apollo 3.5是如何设计Cyber RT计算框架的？</a></p>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, daohu527.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>